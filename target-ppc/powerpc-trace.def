/* This doesn't look like -*- C -*-, but it is!
 *
 * powerpc.def - PowerPC machine definition
 * * This file is a part of the SimpleScalar tool suite written by
 * Todd M. Austin as a part of the Multiscalar Research Project.
 *  
 * The tool suite is currently maintained by Doug Burger and Todd M. Austin.
 * 
 * Copyright (C) 1994, 1995, 1996, 1997, 1998 by Todd M. Austin
 *
 * This source file is distributed "as is" in the hope that it will be
 * useful.  The tool set comes with no warranty, and no author or
 * distributor accepts any responsibility for the consequences of its
 * use. 
 * 
 * Everyone is granted permission to copy, modify and redistribute
 * this tool set under the following conditions:
 * 
 *    This source code is distributed for non-commercial use only. 
 *    Please contact the maintainer for restrictions applying to 
 *    commercial use.
 *
 *    Permission is granted to anyone to make or distribute copies
 *    of this source code, either as received or modified, in any
 *    medium, provided that all copyright notices, permission and
 *    nonwarranty notices are preserved, and that the distributor
 *    grants the recipient permission for further redistribution as
 *    permitted by this document.
 *
 *    Permission is granted to distribute this file in compiled
 *    or executable form under the same conditions that apply for
 *    source code, provided that either:
 *
 *    A. it is accompanied by the corresponding machine-readable
 *       source code,
 *    B. it is accompanied by a written offer, with no time limit,
 *       to give anyone a machine-readable copy of the corresponding
 *       source code in return for reimbursement of the cost of
 *       distribution.  This written offer must permit verbatim
 *       duplication by anyone, or
 *    C. it is distributed by someone who received only the
 *       executable form, and is accompanied by a copy of the
 *       written offer of source code that they received concurrently.
 *
 * In other words, you are welcome to use, share and improve this
 * source file.  You are forbidden to forbid anyone else to use, share
 * and improve what you give them.
 *
 * INTERNET: dburger@cs.wisc.edu
 * US Mail:  1210 W. Dayton Street, Madison, WI 53706
 *
 *
 *
 */

/* This file defines all aspects of the SimpleScalar instruction set
 * architecture.  Each instruction set in the architecture has a DEFINST()
 * macro call included below.  The contents of a instruction definition are
 * as follows:
 *
 *   DEFINST(<enum>,			<opcode>,
 *	     <opname>,			<operands>,
 *	     <fu_req>,			<iflags>,
 *	     <output deps...>,		<input deps...>,
 *	     <expr>)
 *
 * Where:
 *
 *   <enum>	- is an enumerator that is returned when an instruction is
 *		  decoded by SS_OP_ENUM()
 *   <opcode>	- is the opcode of this instruction
 *   <opname>   - name of this instruction as a string, used by disassembler
 *   <operands>	- specified the instruction operand fields and their printed
 * 		  order for disassembly, used by disassembler, the recognized
 *		  operand field are (the instruction format is detailed in
 *		  the header file ss.h):
 *		    J - target field
 *		    j - PC relative target (offset + PC)
 *		    s - S register field
 *		    b - S register field (base register)
 *		    t - T register field
 *		    d - D register field
 *		    S - S register field (FP register)
 *		    T - T register field (FP register)
 *		    D - D register field (FP register)
 *		    o - load address offset (offset)
 *		    i - signed immediate field value
 *		    u - unsigned immediate field value
 *		    U - upper immediate field value
 *		    H - shift amount immediate field value
 *		    B - break code
 *
 *   <fu_req>	- functional unit requirements for this instruction
 *   <iflags>	- instruction flags, accessible via the SS_OP_FLAGS()
 *		  macro, flags are defined with F_* prefix in ss.h
 *   <output deps...>
 *		- a list of up to two output dependency designators, the
 *		  following designators are recognized (place an DNA in any
 *		  unused fields:
 *		    DGPR(N)   - general purpose register N
 *		    DGPR_D(N) - double word general purpose register N
 *		    DCGPR(N)  - general purpose register conditional on
 *			        pre/post- increment/decrement mode
 *		    DFPR_L(N) - floating-point register N, as word
 *		    DFPR_F(N) - floating-point reg N, as single-prec float
 *		    DFPR_D(N) - floating-point reg N, as double-prec double
 *		    DHI	      - HI result register
 *		    DLO	      - LO result register
 *		    DFCC      - floating point condition codes
 * 		    DCPC      - current PC
 *		    DNPC      - next PC
 *		    DNA	      - no dependence
 *
 *   <input deps...>
 *		- a list of up to three input dependency designators, the
 *		  designators are defined above (place an DNA in any unused
 *		  fields.
 *
 *   <expr>	- a C expression that implements the instruction being
 * 		  defined, the expression must modify all architected state
 *		  affected by the instruction's execution, by default, the
 *		  next PC (NPC) value defaults to the current PC (CPC) plus
 *		  SS_INST_SIZE, as a result, only taken branches need to set
 *		  NPC
 *
 *		  The following predefined macros are available for use in
 *		  DEFINST() instruction expressions to access the value of
 *		  instruction operand/opcode field values:
 *
 *		    RS	    - RS register field value
 *		    RT	    - RT register field value
 *		    RD	    - RD register field value
 *		    FS	    - RS register field value
 *		    FT	    - RT register field value
 *		    FD	    - RD register field value
 *		    BS	    - RS register field value
 *		    TARG    - jump target field value
 *		    OFS	    - signed offset field value
 *		    IMM	    - signed offset field value
 *		    UIMM    - unsigned offset field value
 *		    SHAMT   - shift amount field value
 *		    BCODE   - break code field value
 *
 *		  To facilitate the construction of performance simulators
 *		  (which may want to specialize their architected state
 *		  storage format), all architected register and memory state
 *		  is accessed through the following macros:
 *
 *		    GPR(N)         - read general purpose register N
 *		    SET_GPR(N,E)   - write general purpose register N with E
 *		    GPR_D(N)       - read double word general purpose reg N
 *		    SET_GPR_D(N,E) - write double word gen purpose reg N w/ E
 *		    FPR_L(N)       - read floating-point register N, as word
 *		    SET_FPR_L(N,E) - floating-point reg N, as word, with E
 *		    FPR_F(N)       - read FP reg N, as single-prec float
 *		    SET_FPR_F(N,E) - write FP reg N, as single-prec float w/ E
 *		    FPR_D(N)       - read FP reg N, as double-prec double
 *		    SET_FPR_D(N,E) - write FP reg N, as double-prec double w/E
 *		    HI	           - read HI result register
 *		    SET_HI(E)      - write HI result register with E
 *		    LO	           - read LO result register
 *		    SET_LO(E)      - write LO result register with E
 *		    FCC	           - read floating point condition codes
 *		    SET_FCC(E)     - write floating point condition codes w/ E
 *		    CPC	           - read current PC register
 *		    NPC	           - read next PC register
 *		    SET_NPC(E)     - write next PC register with E
 *		    TPC	           - read target PC register
 *		    SET_TPC(E)     - write target PC register with E
 *
 *		    READ_SIGNED_BYTE(A)   - read signed byte from address A
 *		    READ_UNSIGNED_BYTE(A) - read unsigned byte from address A
 *		    READ_SIGNED_HALF(A)   - read signed half from address A
 *		    READ_UNSIGNED_HALF(A) - read unsigned half from address A
 *		    READ_WORD(A)          - read word from address A
 *		    WRITE_BYTE(E,A)       - write byte value E to address A
 *		    WRITE_HALF(E,A)       - write half value E to address A
 *		    WRITE_WORD(E,A)       - write word value E to address A
 *
 *		  Finally, the following helper functions are available to
 *		  assist in the construction of instruction expressions:
 *
 *		    INC_DEC(E,N,S) - execute E and update N as per pre/post-
 *				     incr/decr addressing sementics for an
 *				     access of S bytes
 *		    OVER(X,Y)      - check for overflow for X+Y, both signed
 *		    UNDER(X,Y)	   - check for umderflow for X-Y, both signed
 *		    DIV0(N)	   - check for divide by zero, N is denom
 *		    INTALIGN(N)    - check double word int reg N alignment
 *		    FPALIGN(N)	   - check double word FP reg N alignment
 *		    TALIGN(T)	   - check jump target T alignment
 */

/*Warning: The instructions here are inly the user level instruction supported by
PowerPC. Cache management and system managment user level isntructions have to be
implemented*/

#ifndef DEFTRACE
#define DEFTRACE(word,record_type)
#endif

/* 
 *System Linkage instructions
 */

#define SCACTUAL_IMPL                                   \
  {                                               \
   /* I just love this -- karu  noone understands whats happening*/  \
   if (PPC_GPR(2) == 6) { fprintf(stderr, "Finished execution.\n"); \
      return; }   \
   /* ppc_syscall_fn = PPC_GPR(0);    */              \
   /* ppc_syscall_fn(&regs, mem);   */                \
   dosyscall(PPC_GPR(2), &regs, mem, mem_access);     \
   SET_NPC(LR);                                    \
  }

#define SC_IMPL                                   \
  {                                               \
    SYSCALL;	\
    DEFTRACE(CPC + sizeof(inst), "flow_altering");  /* jdonald hmm  sc */ \
  }


DEFINST(SC,                	0x11,
        "sc",              	"",
        FUClass_NA,             F_TRAP,
        DNA, DNA,               DNA, DNA, DNA,
	DNA, DNA,DNA,		DNA, DNA)


#define TWI_IMPL                                                \
   {                                                            \
        sword_t _sa, _sb;                                       \
        word_t _a, _b;                                          \
        _sa = GPR(RA);                                          \
        _sb = IMM;                                          	\
        _a = (word_t)GPR(RA);                                   \
        _b = UIMM;                                   		\
        if( (_sa < _sb) && (TO & 0x10) )                        \
        {                                                       \
                TRAP;                                           \
        }                                                       \
        else if( (_sa > _sb) && (TO & 0x8) )                    \
        {                                                       \
                TRAP;                                           \
        }                                                       \
        else if( (_sa == _sb) && (TO & 0x4) )                   \
        {                                                       \
                TRAP;                                           \
        }                                                       \
        else  if( (_a < _b) && (TO & 0x2) )                     \
        {                                                       \
                TRAP;                                           \
        }                                                       \
        else if( (_a > _b) && (TO & 0x1) )                     	\
        {                                                       \
                TRAP;                                           \
        }                                                       \
        DEFTRACE(CPC + sizeof(inst), "flow_altering");  /* jdonald hmm */ \
   }

DEFINST(TWI,                    0x3,
        "twi",                  "t,a,b",
        IntALU,                 F_IMM,
        DNA,DNA,                PPC_DGPR(RA),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,         	DNA, DNA)


#define MULLI_IMPL                          \
  {                                         \
    sword_t _sh;                              \
    sword_t _sw;                            \
    sqword_t  _src;                          \
    _sw = GPR(RA);                          \
    _sh = SEXT16(IMM);                      \
    _src = _sw*_sh;                         \
    SET_GPR(RD, (sword_t)(_src&ULL(0x00000000ffffffff)));\
  }

DEFINST(MULLI,                  0x07,
        "mulli",                "d,a,i",
        IntMULT,                F_ICOMP|F_IMM|F_LONGLAT,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), DNA, DNA,
        DNA, DNA, DNA,          DNA, DNA)


#define SUBFIC_IMPL                             \
  {                                             \
	 word_t ra;												\
	 ra = GPR(RA);											\
    SET_GPR(RD,  SEXT16(IMM) - GPR(RA));                \
	 if (ra == 0) PPC_SET_XER_CA; else {		\
	   if(carrygenerated( -ra, SEXT16(IMM))){         \
     	   PPC_SET_XER_CA;                         \
    	}                                           \
    		else{ PPC_RESET_XER_CA;                    \
	 	}														\
	}															\
  }

DEFINST(SUBFIC,                 	0x08,
        "subfic",               	"d,a,i",  
        IntALU,                 	F_ICOMP|F_IMM,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)





#define ADDIC_IMPL				\
  {						\
	 word_t ra;					\
	 ra = GPR(RA);				\
    SET_GPR(RD, GPR(RA) + SEXT16(IMM) );			\
    if(carrygenerated(ra, SEXT16(IMM) ) ){       	\
    	PPC_SET_XER_CA;                         \
    }                                           \
    else{ PPC_RESET_XER_CA;}			\
  }

DEFINST(ADDIC,                  	0x0C,
        "addic",                	"d,a,i",
        IntALU,                 	F_ICOMP|F_IMM,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)


#define CMPLI_IMPL                                                     	\
   {                                                                    \
        word_t _a, _b;                                                 	\
        word_t _c;                                                  \
        word_t _mask;                                                   \
  	if(ISSETL) {                                                    \
                DECLARE_FAULT(md_fault_invalidinstruction);             \
        }                                                               \
	else{								\
	        _a = GPR(RA);                                           \
        	_b = UIMM;                                              \
       		if(_a<_b) _c=0x8;                                       \
        	else{                                                   \
                	if (_a>_b) _c=0x4;                              \
               	 	else      _c=0x2;                               \
        	}                                                       \
        	_c = _c | (PPC_GET_XER_SO);                             \
			_c = _c << 4 * (7 - CRFD);		\
			_mask = ~( 0xf << 4 * (7 - CRFD));		\
			PPC_SET_CR ( ( CR & _mask ) | _c);		\
       	} 	                                                        \
   }
                

DEFINST(CMPLI,                  0xA,
        "cmpli",                "r,l,a,i",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DCR, DNA,           PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
        DNA, DNA, DNA,        	PPC_DXER, DNA)


#define CMPI_IMPL                                                       \
   {                                                                    \
        sword_t _a, _b;                                                 \
        word_t _c, _d;                                                  \
        word_t _mask;                                                   \
  	if(ISSETL) {                                                    \
                DECLARE_FAULT(md_fault_invalidinstruction);             \
        }                                                               \
        else{                                                           \
	        _a = GPR(RA);                                           \
	        _b = IMM;                                               \
	        if(_a<_b) _c=0x8;                                       \
	        else{                                                   \
                	if (_a>_b) _c=0x4;                              \
                	else      _c=0x2;                               \
        	}                                                       \
      	 	_c = _c | (PPC_GET_XER_SO);                             \
        	_c = _c << ( (7-CRFD)*4 );                              \
       		if(CRFD==0){                                            \
                	_mask = 0xf << 28 ;                             \
                	PPC_SET_CR( (CR & (~(_mask))) | _c );           \
        	}                                                       \
        	else{                                                   \
                	_d = _c <<28;                                   \
                	_mask = (0xf << ( (7-CRFD)*4 )) | 0xf0000000;   \
                	_mask = (0xf << ( (7-CRFD)*4 )) ;   \
/* dont know why prev line ored with 0xf000000, removed it. hope this works */ \
                	PPC_SET_CR((CR & (~(_mask))) | _c );        \
        	}                                                       \
	}								\
   }
    

DEFINST(CMPI,                   0xB,
        "cmpi",                 "r,l,a,i",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DCR, DNA,           PPC_DGPR(RA), PPC_DCR, PPC_DXER,
        DNA, DNA, DNA,        	DNA, DNA)


#define ADDICD_IMPL                             \
  {                                             \
    sword_t _src;				\
    _src= GPR(RA) + SEXT16(IMM); 		        \
    if(carrygenerated(GPR(RA), SEXT16(IMM) )){           \
        PPC_SET_XER_CA;                         \
    }                                           \
    else{ PPC_RESET_XER_CA;}                    \
        if(!(_src)) PPC_SET_CR0_EQ;             \
        else PPC_RESET_CR0_EQ;                  \
        if(_src>0) PPC_SET_CR0_GT;              \
        else PPC_RESET_CR0_GT;                  \
        if(_src<0) PPC_SET_CR0_LT;              \
        else PPC_RESET_CR0_LT;                  \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;      \
        else PPC_RESET_CR0_SO;                  \
        SET_GPR(RD, _src);                      \
  }
        
DEFINST(ADDICD,                 	0x0D,
        "addic.",               	"d,a,i",
        IntALU,                 	F_ICOMP|F_IMM,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA)


#define ADDI_IMPL				\
  {						\
    if(RA==0) SET_GPR(RD, SEXT16(IMM) );			\
    else     SET_GPR(RD, GPR(RA) + SEXT16(IMM) );	\
  }

DEFINST(ADDI,			0x0E,
	"addi",			"d,a,i",
	IntALU,			F_ICOMP|F_IMM,
	PPC_DGPR(RD), DNA, 	PPC_DGPR(RA), DNA, DNA,
	DNA,DNA,DNA,		DNA,DNA)




#define ADDIS_IMPL						\
  {								\
  if(RA==0) SET_GPR(RD, (IMM << 16));				\
  else      SET_GPR(RD, GPR(RA) + (IMM<<16));			\
  }

DEFINST(ADDIS,			0x0F,
        "addis",		"d,a,i",
        IntALU,			F_ICOMP|F_IMM,
        PPC_DGPR(RD),DNA,	PPC_DGPR(RA),DNA,DNA,
	DNA,DNA,DNA,		DNA,DNA)



#define ORI_IMPL							\
   {									\
	SET_GPR(RA, (GPR(RS)|UIMM));					\
   }  

DEFINST(ORI,			0x18,
        "ori",			"a,s,u",
        IntALU,			F_ICOMP|F_IMM,
        PPC_DGPR(RA),DNA,	PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)



#define ORIS_IMPL							\
   {									\
     SET_GPR(RA, (GPR(RS)|(UIMM << 16)));				\
   }  

DEFINST(ORIS,			0x19,
        "oris",			"a,s,u",
        IntALU,			F_ICOMP|F_IMM,
        PPC_DGPR(RA),DNA,	PPC_DGPR(RS),DNA,DNA,
	DNA, DNA,DNA,        	DNA, DNA)



#define XORI_IMPL							\
   {                                                                    \
     SET_GPR(RA, (GPR(RS)^(UIMM)));                                       \
   }

DEFINST(XORI,                   0x1A,
        "xori",                 "a,s,u",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define XORIS_IMPL                                                      \
   {                                                                    \
     SET_GPR(RA, (GPR(RS)^((UIMM) << 16)));                               \
   }

DEFINST(XORIS,                  0x1B,
        "xoris",                "a,s,u",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)

#define ANDID_IMPL							\
   {	                                                                \
        word_t _src;                                                    \
        _src = GPR(RS)& UIMM;					        \
	SET_GPR(RA, _src);					        \
	if(!(_src)) PPC_SET_CR0_EQ;					\
	else PPC_RESET_CR0_EQ;						\
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
	if(PPC_GET_XER_SO) PPC_SET_CR0_SO;	      			\
	else PPC_RESET_CR0_SO;						\
   }

DEFINST(ANDID,			0x1C,
	"andi.",	       	"a,s,u",
	IntALU,			F_ICOMP|F_IMM,
	PPC_DGPR(RA),DNA,	PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)
		

#define ANDISD_IMPL							\
   {	                                                                \
        word_t _src;                                                    \
        _src = GPR(RS)& (UIMM<<16);				        \
	SET_GPR(RA, _src);					        \
	if(!(_src)) PPC_SET_CR0_EQ;					\
	else PPC_RESET_CR0_EQ;						\
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
	if(PPC_GET_XER_SO) PPC_SET_CR0_SO;				\
	else PPC_RESET_CR0_SO;						\
   }

DEFINST(ANDISD,			0x1D,
	"andis.",	       	"a,s,u",
	IntALU,			F_ICOMP|F_IMM,
	PPC_DGPR(RA),DNA,	PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)
		


#define LWZ_IMPL                                                        \
   {                                                                    \
    word_t _result;                                                     \
    enum md_fault_type _fault;                                          \
    if(RA==0)                                                           \
        {                                                               \
           _result = READ_WORD(OFS, _fault);                            \
    		DEFTRACE(OFS, "memory"); 		\
        }                                                               \
    else                                                                \
        {                                                               \
           _result = READ_WORD(GPR(RA)+SEXT16(OFS), _fault);             \
    		DEFTRACE(GPR(RA) + SEXT16(OFS), "memory"); 		\
        }       							 							\
        if (_fault != md_fault_none)        	                  		\
               DECLARE_FAULT(_fault);                                  	\
        SET_GPR(RD, _result);		                        	\
   }


DEFINST(LWZ,                    0x20,
        "lwz",                  "d,o(a)",
        RdPort,                 F_MEM|F_LOAD|F_DISP,
	PPC_DGPR(RD),DNA,       DNA, PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define LWZU_IMPL                                                       \
   {                                                                    \
    word_t _result;                                                     \
    enum md_fault_type _fault;                                          \
    if(RA==0||(RA==RD))                                                 \
        {                                                               \
           DECLARE_FAULT(md_fault_invalidinstruction);                  \
        }                                                               \
    else{                                                               \
           _result = READ_WORD(GPR(RA)+SEXT16(OFS), _fault);            \
    		DEFTRACE(GPR(RA) + SEXT16(OFS), "memory"); 		\
           if (_fault != md_fault_none)                                 \
       		   DECLARE_FAULT(_fault);                               \
           SET_GPR(RD, _result);                                        \
	   SET_GPR(RA, GPR(RA)+SEXT16(OFS));					\
        }                                                               \
   }
        

DEFINST(LWZU,                   	0x21,
        "lwzu",                 	"d,o(a)",
        RdPort,                 	F_MEM|F_LOAD|F_DISP,
        PPC_DGPR(RD), DNA,      DNA, PPC_DGPR(RA),DNA,
        PPC_DGPR(RA), DNA, DNA,        		DNA, DNA)
   
#define LBZ_IMPL							\
   {									\
     byte_t _result;							\
     enum md_fault_type _fault;						\
									\
     if(RA==0){								\
		_result = READ_BYTE(SEXT16(OFS),_fault);			\
    	DEFTRACE(SEXT16(OFS), "memory");      \
    }													\
    else{								\
		 _result = READ_BYTE(GPR(RA) + SEXT16(OFS), _fault);		\
    	 DEFTRACE(GPR(RA) + SEXT16(OFS), "memory");      \
	}								\
	if (_fault != md_fault_none)                            	\
               	DECLARE_FAULT(_fault);                          	\
        SET_GPR(RD, (word_t)_result);                           	\
   }

DEFINST(LBZ,			0x22,
	"lbz",			"d,o(a)",		                  
	RdPort,			F_MEM|F_LOAD|F_DISP,
	PPC_DGPR(RD),DNA,	DNA, PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define LBZU_IMPL                                                       \
   {                                                                    \
     byte_t _result;                                                    \
     enum md_fault_type _fault;                                         \
                                                                        \
     if((RA==0)||(RA==RD)){                                             \
                DECLARE_FAULT(md_fault_invalidinstruction);		\
        }                                                               \
     else{                                                              \
                _result = READ_BYTE(GPR(RA) + SEXT16(OFS), _fault);    	\
                DEFTRACE(GPR(RA) + SEXT16(OFS), "memory");      \
                if (_fault != md_fault_none)                            \
                DECLARE_FAULT(_fault);                                  \
                SET_GPR(RD, (word_t)_result);                           \
		SET_GPR(RA, GPR(RA) + SEXT16(OFS));				\
        }                                                               \
   }
                        
DEFINST(LBZU,                           0x23,
        "lbzu",                         "d, o(a)",
        RdPort,                         F_MEM|F_LOAD|F_DISP,
        PPC_DGPR(RD), DNA,      DNA, PPC_DGPR(RA), DNA,
        PPC_DGPR(RA), DNA, DNA,                 DNA, DNA)




#define STW_IMPL                                                        \
   {                                                                    \
    word_t _src;                                                        \
    enum md_fault_type _fault;                                          \
                                                                        \
    _src = (word_t)GPR(RS);                                     	\
    if(RA==0){                                                          \
                WRITE_WORD(_src,  OFS, _fault);                         \
				DEFTRACE(OFS, "memory"); 		\
        }                                                               \
    else{                                                               \
                WRITE_WORD(_src, GPR(RA) + SEXT16(OFS), _fault);        \
				DEFTRACE(GPR(RA) + SEXT16(OFS), "memory"); 		\
        }                                                               \
    if (_fault != md_fault_none)                                        \
      DECLARE_FAULT(_fault);                                            \
   }
                
DEFINST(STW,                   0x24,
        "stw",                 "s,o(a)",
        WrPort,                F_MEM|F_STORE|F_DISP,
        DNA,DNA,               PPC_DGPR(RS),PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,         DNA, DNA)



#define STWU_IMPL                                                       \
   {                                                                    \
    word_t _src;                                                        \
    enum md_fault_type _fault;                                          \
                                                                        \
    if(RA==0){                                                          \
                 DECLARE_FAULT(md_fault_invalidinstruction);            \
        }                                                               \
    else{                                                               \
            _src = (word_t)GPR(RS);                             	\
            WRITE_WORD(_src, GPR(RA) + SEXT16(OFS), _fault);            \
			DEFTRACE(GPR(RA) + SEXT16(OFS), "memory"); 		\
            if (_fault != md_fault_none)                                \
                DECLARE_FAULT(_fault);                                  \
	     SET_GPR(RA, GPR(RA)+SEXT16(OFS));					\
        }                                                               \
   }
        
DEFINST(STWU,                   0x25,
        "stwu",                 "s,o(a)",
        WrPort,                 F_MEM|F_STORE|F_DISP,
        DNA,DNA,       PPC_DGPR(RS),PPC_DGPR(RA),DNA,
        PPC_DGPR(RA), DNA, DNA,           DNA, DNA)


#define STB_IMPL							\
   {									\
	byte_t	_src;							\
	enum md_fault_type _fault;                                      \
	_src=(byte_t)(word_t)GPR(RS);					\
        if(RA==0){                                                      \
                 WRITE_BYTE(_src, OFS, _fault);      			\
         		DEFTRACE(OFS, "memory"); 		\
        }		                                                \
        else{                                                           \
             WRITE_BYTE( _src, GPR(RA)+SEXT16(OFS), _fault);  	\
         	 DEFTRACE(GPR(RA)+SEXT16(OFS), "memory"); 		\
        }                                                               \
	if (_fault != md_fault_none)		                        \
                DECLARE_FAULT(_fault);                                  \
   }

DEFINST(STB,                    0x26,
        "stb",                  "s,o(a)",
        WrPort,                 F_MEM|F_STORE|F_DISP,
        DNA,DNA,                PPC_DGPR(RS),PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,          DNA, DNA)

#define STBU_IMPL                                                       \
   {                                                                    \
        byte_t  _src;                                                   \
        enum md_fault_type _fault;                                      \
        if(RA==0){                                                      \
	 	 DECLARE_FAULT(md_fault_invalidinstruction);            \
        }								\
        else{                                                           \
             _src=(byte_t)(word_t)GPR(RS);                              \
             WRITE_BYTE( _src, GPR(RA)+OFS, _fault);                    \
         	 DEFTRACE(GPR(RA)+OFS, "memory"); 		\
             if (_fault != md_fault_none)                               \
                DECLARE_FAULT(_fault);                                  \
	     SET_GPR(RA, GPR(RA)+OFS);					\
        }                                                               \
   }
   
DEFINST(STBU,                   0x27,
        "stbu",                 "s, o(a)",
        WrPort,                 F_MEM|F_STORE|F_DISP,
        DNA, DNA,       PPC_DGPR(RS),PPC_DGPR(RA),DNA,
        PPC_DGPR(RA), DNA, DNA,         DNA, DNA)

#define LHZ_IMPL                                                        \
   {                                                                    \
    half_t _result;                                                     \
    enum md_fault_type _fault;                                          \
    if(RA==0)                                                           \
        {                                                               \
           _result = READ_HALF(OFS, _fault);                            \
    	   DEFTRACE(OFS, "memory"); 		\
        }                                                               \
    else                                                                \
        {                                                               \
	   		_result = READ_HALF(GPR(RA)+OFS, _fault);                    \
	    	DEFTRACE(GPR(RA) + OFS, "memory"); 		\
        }                                                               \
	if (_fault != md_fault_none)                                	\
		DECLARE_FAULT(_fault);                                  \
        SET_GPR(RD, (word_t)_result);                                	\
   }
    
DEFINST(LHZ,                    0x28,
        "lhz",                  "d,o(a)",
        RdPort,                 F_MEM|F_LOAD|F_DISP,
        PPC_DGPR(RD),DNA,       DNA, PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,          DNA, DNA)

#define LHZU_IMPL                                                       \
   {                                                                    \
    half_t _result;                                                     \
    enum md_fault_type _fault;                                          \
    if(RA==0||(RA==RD))                                                 \
        {                                                               \
	   DECLARE_FAULT(md_fault_invalidinstruction);             	\
        }								\
    else                                                                \
        {                                                               \
           _result = READ_HALF(GPR(RA)+OFS, _fault);                    \
    	   DEFTRACE(GPR(RA) + OFS, "memory"); 		\
           if (_fault != md_fault_none)                                 \
                DECLARE_FAULT(_fault);                                  \
           SET_GPR(RD, (word_t)_result);                                \
	   SET_GPR(RA, GPR(RA)+OFS);					\
        }                                                               \
   }

DEFINST(LHZU,                           0x29,
        "lhzu",                         "d, o(a)",
        RdPort,                         F_MEM|F_LOAD|F_DISP,
        PPC_DGPR(RD), DNA,      DNA, PPC_DGPR(RA), DNA,
        PPC_DGPR(RA), DNA, DNA,                 DNA, DNA)
    

#define LHA_IMPL                                                        \
   {                                                                    \
    shalf_t _result;                                                    \
    enum md_fault_type _fault;                                          \
    if(RA==0)								\
	{								\
 	   _result = READ_HALF(OFS, _fault);		                \
       DEFTRACE(OFS, "memory"); 		\
  	}								\
    else								\
	{								\
		_result = READ_HALF(GPR(RA)+OFS, _fault);			\
    	DEFTRACE(GPR(RA) + OFS, "memory"); 		\
	}								\
    if (_fault != md_fault_none)                                	\
                DECLARE_FAULT(_fault);                                  \
        SET_GPR(RD, (word_t)(sword_t)_result);                       	\
   }
    
DEFINST(LHA,                    0x2A,
        "lha",                  "d,o(a)",
        RdPort,                 F_MEM|F_LOAD|F_DISP,
        PPC_DGPR(RD),DNA,       DNA, PPC_DGPR(RA), DNA,
        DNA, DNA, DNA,          DNA, DNA)


#define LHAU_IMPL                                                       \
   {                                                                    \
    shalf_t _result;                                                    \
    enum md_fault_type _fault;                                          \
    if((RA==0)||(RA==RD)){                                              \
                DECLARE_FAULT(md_fault_invalidinstruction);             \
        }                                                               \
    else{                                                               \
        _result = READ_HALF(GPR(RA)+OFS, _fault);                   	\
    	DEFTRACE(GPR(RA) + OFS, "memory"); 		\
            if (_fault != md_fault_none)                                \
                DECLARE_FAULT(_fault);                                  \
           SET_GPR(RD, (word_t)(sword_t)_result);                      	\
	   SET_GPR(RA, GPR(RA) + OFS);                             	\
        }                                                               \
   }
    
DEFINST(LHAU,                           0x2B,
        "lhau",                         "d,o(a)",
        RdPort,                         F_MEM|F_LOAD|F_DISP,
        PPC_DGPR(RD), DNA,      DNA, PPC_DGPR(RA), DNA,
        PPC_DGPR(RA), DNA, DNA,                 DNA, DNA)


#define STHU_IMPL							\
   {									\
    half_t _src;                                                        \
    enum md_fault_type _fault;                                          \
                                                                        \
    if(RA==0){								\
		 DECLARE_FAULT(md_fault_invalidinstruction);            \
	}                                               		\
    else{								\
	    _src = (half_t)(word_t)GPR(RS);                             \
	    WRITE_HALF(_src, GPR(RA) + OFS, _fault);            	\
		DEFTRACE(GPR(RA) + OFS, "memory"); 		\
	    if (_fault != md_fault_none)                                \
      		DECLARE_FAULT(_fault);                                  \
	     SET_GPR(RA, GPR(RA)+OFS);					\
	} 								\
   }

DEFINST(STHU,                   0x2D,
        "sthu",                 "s,o(a)",
        WrPort,                 F_MEM|F_STORE|F_DISP,
        DNA,DNA,        PPC_DGPR(RS),PPC_DGPR(RA),DNA,
        PPC_DGPR(RA), DNA, DNA,         DNA, DNA)
 

#define STH_IMPL                                                        \
   {                                                                    \
    half_t _src;                                                        \
    enum md_fault_type _fault;                                          \
                                                                        \
    _src = (half_t)(word_t)GPR(RS);                                     \
    if(RA==0){                                                          \
                WRITE_HALF(_src,  OFS, _fault);                         \
				DEFTRACE(OFS, "memory");  		\
        }                                                               \
    else{                                                               \
                WRITE_HALF(_src, GPR(RA) + OFS, _fault);                \
				DEFTRACE(GPR(RA) + OFS, "memory");  		\
        }                                                               \
    if (_fault != md_fault_none)                                        \
      DECLARE_FAULT(_fault);                                            \
   }         

DEFINST(STH,                   0x2C,
        "sth",                 "s,o(a)",
        WrPort,                F_MEM|F_STORE|F_DISP,
        DNA,DNA,               PPC_DGPR(RS),PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,         DNA, DNA)
  
#define LMW_IMPL                                                       	\
   {                                                                    \
    word_t _result,_reg;						\
    enum md_fault_type _fault;                                          \
    sword_t _ea;							\
    if(RA==0)                                                           \
        {                                                               \
           _ea = OFS;                        				\
        }                                                               \
    else                                                                \
        {                                                               \
           _ea = GPR(RA)+OFS;                				\
        }                                                               \
	_reg=RD;							\
	DEFTRACE(_ea, "memory"); 		\
	while(_reg<MD_NUM_IREGS){					\
		_result = READ_WORD(_ea, _fault);			\
        	if (_fault != md_fault_none)                            \
               		DECLARE_FAULT(_fault);                          \
        	SET_GPR(_reg, _result);                                 \
		_reg++;							\
		_ea=_ea+4;						\
	}								\
   }

DEFINST(LMW,                                    0x2E,
        "lmw",                                  "d,o(a)",
        RdPort,                                 F_MEM|F_LOAD|F_DISP,
        PPC_DGPR(RD),DNA,                               DNA, PPC_DGPR(RA), DNA,
        DNA, DNA, DNA,                  DNA, DNA)
 

#define STMW_IMPL                                                       \
   {                                                                    \
    word_t _result,_reg;                                                \
    enum md_fault_type _fault;                                          \
    sword_t _ea;                                                        \
    if(RA==0)                                                           \
        {                                                               \
           _ea = OFS;                                               	\
        }                                                               \
    else                                                                \
        {                                                               \
           _ea = GPR(RA)+OFS;                                       	\
        }                                                               \
        _reg=RD;                                                        \
		DEFTRACE(_ea + OFS, "memory"); 		\
        while(_reg<MD_NUM_IREGS){                                       \
		_result=GPR(_reg);					\
		/* karu comment: I believe src and dst are intechanged */ \
                WRITE_WORD(_result, _ea, _fault);		\
                if (_fault != md_fault_none) {                          \
                        DECLARE_FAULT(_fault);                          \
					 } 							\
		_result = 0;						\
		_result = READ_WORD(_ea, _fault);			\
                if (_fault != md_fault_none) {                          \
                        DECLARE_FAULT(_fault);                          \
                }                                                       \
                _reg++;                                                 \
                _ea=_ea+4;                                              \
        }                                                               \
   }

DEFINST(STMW,                                   0x2F,
        "stmw",                                 "s,o(a)",
        RdPort,                                 F_MEM|F_STORE|F_DISP,
        DNA,DNA,                                PPC_DGPR(RS),PPC_DGPR(RA), DNA,
        DNA,DNA,DNA,                            DNA, DNA)

#define LFS_IMPL                                                        \
   {                                                                    \
     word_t _result;                                                    \
     enum md_fault_type _fault;                                         \
     dfloat_t _da;							\
     if(RA==0){                                                         \
                _result = READ_WORD(OFS,_fault);                        \
    			DEFTRACE(OFS, "memory"); 		\
        }                                                               \
     else{                                                              \
                 _result = READ_WORD(GPR(RA) + OFS, _fault);            \
    			DEFTRACE(GPR(RA) + OFS, "memory"); 					\
        }								\
        if(_fault!=md_fault_none)                               	\
        	DECLARE_FAULT(_fault);                          	\
		  _da =(dfloat_t)( *((sfloat_t*)(&_result)));	 	\
        PPC_SET_FPR_D(RD, _da);                                 	\
   }    

DEFINST(LFS,                    0x30,
        "lfs",                  "D, o(a)",
        RdPort,                 F_MEM|F_LOAD|F_DISP,
        PPC_DFPR(FD),DNA,       DNA, PPC_DGPR(RA), DNA,
        DNA, DNA, DNA,          DNA, DNA)

#define LFSU_IMPL                                                       \
   {                                                                    \
     word_t _result;                                                    \
     enum md_fault_type _fault;                                         \
     dfloat_t _da;							\
                                                                        \
     if(RA==0){                                                         \
        	DECLARE_FAULT(md_fault_invalidinstruction);             \
     }                                                               	\
     else{                                                              \
                _result = READ_WORD(GPR(RA) + OFS, _fault);             \
    			DEFTRACE(GPR(RA) + OFS, "memory"); 		\
                if (_fault != md_fault_none)                            \
                DECLARE_FAULT(_fault);                                  \
		_da =(dfloat_t)( *((sfloat_t*)(&_result)));		\
        	PPC_SET_FPR_D(RD, _da);                                 \
		SET_GPR(RA, GPR(RA) + OFS);				\
        }                                                               \
   }

DEFINST(LFSU,                           0x31,
        "lfsu",                         "D,o(a)",
        RdPort,                         F_MEM|F_LOAD|F_DISP,
        PPC_DFPR(FD),PPC_DGPR(RA),      DNA, PPC_DGPR(RA), DNA,
        DNA, DNA, DNA,                  DNA, DNA)



#define LFD_IMPL                                                     	\
  {                                                                     \
    enum md_fault_type _fault;                                          \
    sword_t _ea;    							\
    qword_t _res;							\
    word_t _a1, _a2; \
    if(RA==0) _ea = OFS;						\
    else      _ea = GPR(RA) + OFS;					\
	/* _res = READ_QWORD(_ea, _fault); */		\
    _a1 = READ_WORD(_ea, _fault); _a2 = READ_WORD(_ea+4, _fault); \
    DEFTRACE(_ea, "memory"); /* jdonald alignment? */     \
    _res = _a2 | ((qword_t) _a1) << 32; \
    if (_fault != md_fault_none)                                        \
      DECLARE_FAULT(_fault);                                            \
    PPC_SET_FPR_DW(FD, _res);	                                        \
  }

DEFINST(LFD,                    0x32,
        "lfd",                  "D,o(a)",
        RdPort,                 F_MEM|F_LOAD|F_DISP,
        PPC_DFPR(FD), DNA,      DNA, PPC_DGPR(RA), DNA,
        DNA, DNA, DNA,          DNA, DNA)



#define LFDU_IMPL                                                       \
  {                                                                     \
    enum md_fault_type _fault;                                          \
    sword_t _ea;							\
    qword_t _res;                                                 \
    word_t _a1, _a2; \
    if(RA==0){                                                         	\
                DECLARE_FAULT(md_fault_invalidinstruction);             \
     }                                                                  \
    else{								\
    _ea = GPR(RA) + OFS;                         		\
 	/* _res = READ_QWORD(_ea, _fault);       */    \
    _a1 = READ_WORD(_ea, _fault); _a2 = READ_WORD(_ea+4, _fault); \
    DEFTRACE(_ea, "memory"); /* jdonald alignment? */		\
    _res = _a2 | ((qword_t) _a1) << 32; \
    if (_fault != md_fault_none)                            \
    	DECLARE_FAULT(_fault);                          \
    PPC_SET_FPR_DW(FD, _res);                               \
	 SET_GPR(RA,_ea);					\
	}  								\
  }

DEFINST(LFDU,                           0x33,
        "lfdu",                         "D,o(a)",
        RdPort,                         F_MEM|F_LOAD|F_DISP,
        PPC_DFPR(FD), PPC_DGPR(RA),     DNA, PPC_DGPR(RA), DNA,
        DNA, DNA, DNA,                  DNA, DNA)

#define STFS_IMPL							\
{									\
	enum md_fault_type _fault;                                      \
	float tempf; 				\
	word_t *ptempf;			\
	double double_a;		\
   	qword_t _d =PPC_FPR_DW(FS);      \
	memcpy(&double_a, &_d, sizeof(double_a) ); \
        tempf = (float) double_a;                  \
        ptempf = (word_t *) (&tempf);              \
	if(RA==0) {							\
		WRITE_WORD(*ptempf, OFS, _fault);	\
		DEFTRACE(OFS, "memory");  		\
	}							\
	else{								\
		WRITE_WORD(*ptempf, GPR(RA)+OFS, _fault); \
		DEFTRACE(GPR(RA) + OFS, "memory");  		\
	}		                                                \
   if (_fault != md_fault_none)                               	\
   	DECLARE_FAULT(_fault);                                  \
}

DEFINST(STFS,                   0x34,
        "stfs",                 "S,o(a)",
        WrPort,                 F_MEM|F_STORE|F_DISP,
        DNA,DNA,                PPC_DFPR(FS),PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,          DNA, DNA)

#define STFSU_IMPL                                                      \
{                                                                    \
	enum md_fault_type _fault;                                      \
   float tempf;            \
   word_t *ptempf;         \
   double double_a;             \
   qword_t _d =PPC_FPR_DW(FS);      \
   memcpy(&double_a, &_d, sizeof(double) ); \
   tempf = (float) double_a;                       \
   ptempf = (word_t *) (&tempf);    \
   WRITE_WORD(*ptempf, GPR(RA)+OFS, _fault);\
   DEFTRACE(GPR(RA) + OFS, "memory"); 		\
   if (_fault != md_fault_none)                                \
      DECLARE_FAULT(_fault);                                  \
	SET_GPR(RA, GPR(RA)+OFS);											\
}
        
DEFINST(STFSU,                  0x35,
        "stfsu",                "S,o(a)",
        WrPort,                 F_MEM|F_STORE|F_DISP,
        PPC_DGPR(RA),DNA,       PPC_DFPR(FS),PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,          DNA, DNA)

        

#define STFD_IMPL                                                       \
   {                                                                    \
	enum md_fault_type _fault;                                      \
	if(RA==0){                                                      \
		WRITE_WORD((PPC_FPR_UW(FS)), OFS, _fault);                 \
        DEFTRACE(OFS, "memory"); /* jdonald alignment? */ 		\
		if (_fault != md_fault_none)				\
			DECLARE_FAULT(_fault);                              \
		WRITE_WORD((PPC_FPR_W(FS)), OFS+4, _fault);		\
		if (_fault != md_fault_none)				\
			DECLARE_FAULT(_fault);                              \
	}                                                       \
	else{                                                           \
		WRITE_WORD((PPC_FPR_UW(FS)), GPR(RA)+OFS, _fault);             \
		DEFTRACE(GPR(RA) + OFS, "memory"); /* jdonald alignment? */ 		\
		if (_fault != md_fault_none)                               \
			DECLARE_FAULT(_fault);                                  \
		WRITE_WORD((PPC_FPR_W(FS)), GPR(RA)+OFS+4, _fault);            \
		if (_fault != md_fault_none)                               \
			DECLARE_FAULT(_fault);                                  \
	}                                                               \
}

DEFINST(STFD,                   0x36,
        "stfd",                 "S, o(a)",
        WrPort,                 F_MEM|F_STORE|F_DISP,
        DNA,DNA,                PPC_DFPR(FS),PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,          DNA, DNA)

#define STFDU_IMPL                                                      \
   {                                                                    \
        enum md_fault_type _fault;                                      \
        if(RA==0){                                                      \
                DECLARE_FAULT(md_fault_invalidinstruction);             \
                }                                                       \
        else{                                                           \
                WRITE_WORD( (PPC_FPR_UW(FS)), GPR(RA)+OFS, _fault);         \
				DEFTRACE(GPR(RA) + OFS, "memory"); /* jdonald alignment? */ 		\
                if (_fault != md_fault_none)                            \
                        DECLARE_FAULT(_fault);                          \
                WRITE_WORD( (PPC_FPR_W(FS)), GPR(RA)+OFS+4, _fault);	\
                if (_fault != md_fault_none)                            \
                        DECLARE_FAULT(_fault);                          \
                SET_GPR(RA, GPR(RA)+OFS);                               \
        }                                                               \
   }
             
DEFINST(STFDU,                  0x37,
        "stfdu",                "S, o(a)",
        WrPort,                 F_MEM|F_STORE|F_DISP,
        PPC_DGPR(RA),DNA,       PPC_DFPR(FS),PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,          DNA, DNA)

/*All the instructions which have a common opcode and then an extenede opcode are
grouped together here. A name given to that group is defined in the
DEFLINK and the DEFINST for all the instructions contain the extended opcode. The
instruction decode than decodes the grouped instructions with a common opcode using 
this. To see the groups here refer to the programmers manual of PowerPC*/


DEFLINK(FDIVS_LINK, 0x3B, "fdivs_link", 0, 0x3f, 0) 
DEFLINK(FCMPU_LINK, 0x3f, "fcmpu_link", 0, 0x7ff, 0x3f) 
DEFLINK(CMP_LINK, 0x1f, "cmpl_link", 0, 0x7ff, 0) 
DEFLINK(B_LINK, 0x12, "b_link", 0, 0x3, 0) 
DEFLINK(RLWNM_LINK, 0x17, "rlwnm_link", 0, 0x1, 0) 
DEFLINK(RLWINM_LINK, 0x15, "rlwinm_link", 0, 0x1, 0) 
DEFLINK(RLWIMI_LINK, 0x14, "rlwimi_link", 0, 0x1, 0) 
DEFLINK(MCRF_LINK, 0x13, "mcrf_link", 0, 0x7ff, 0)
DEFLINK(BC_LINK, 0x10, "bc_link", 0, 0x3, 0) 

CONNECT(BC_LINK)

#define BC_IMPL                  \
   {                    \
    word_t _ctr, PC;                         \
    word_t ctr_ok;                        \
    word_t cond_ok;                       \
    word_t nia;                           \
    _ctr= CNTR; PC = CPC;                 \
    if (DECREMENTS_CTR (inst)) { \
        _ctr--; PPC_SET_CNTR(_ctr);                   \
        if (BR_IF_CTR_ZERO (inst)) {                  \
            ctr_ok = (_ctr == 0);                     \
        } else {                                      \
            ctr_ok = (_ctr != 0);                     \
        }                                             \
    } else {                                          \
        ctr_ok = 1;  \
    }                \
    \
    if (CONDITIONAL_BR (inst)) {       \
        if (BR_IF_TRUE (inst)) {       \
            cond_ok = (CR << GET_BI (inst)) & 0x80000000;   \
        } else {                                            \
            cond_ok = !((CR << GET_BI (inst)) & 0x80000000);   \
        }                                                   \
    } else {   \
        cond_ok = 1; \
    } \
    if (GET_LK (inst))     \
        LR =PC + sizeof(inst);   \
    if (ctr_ok && cond_ok) {     \
        if (GET_AA (inst)) {     \
            nia = SEXT16(BD<<2);    \
        } else {                       \
            nia = PC + SEXT16(BD<<2);  \
        }                              \
        SET_NPC(nia);                  \
		DEFTRACE( nia, "flow_altering"); \
    } else {                           \
        SET_NPC(PC + sizeof(inst) );   \
        DEFTRACE(PC + sizeof(inst), "flow_altering");   \
    }                                  \
}

       
DEFINST(BC,                    0x0,
        "bc",                  "f,g,k",
        IntALU,                F_CTRL|F_COND|F_DIRJMP,
        PPC_DCNTR,DNA,         PPC_DCNTR,DNA,DNA,
        DNA, DNA, DNA,         DNA, DNA)


   
#define BCL_IMPL                                        \
   {                                                    \
    word_t _ctr,_bflag=0,_cond;                          \
    _ctr= CNTR;                                         \
    if(!(0x4&BO)){                                      \
         _ctr=_ctr-1;                                   \
        PPC_SET_CNTR(_ctr);                             \
    }                                                   \
    _cond = (CR>>(31-BI))&0x1;                          \
                                                        \
     if(0x10&BO){                                       \
        if(0x14&BO) _bflag=1;                           \
        if( (0x12&BO) && (_ctr==0) ) _bflag=1;          \
        else if(_ctr!=0) _bflag=1;                       \
     }                                                  \
     else if(0x8&BO){                                   \
        if(_cond){                                      \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;               \
        }                                               \
     }                                                  \
     else{                                              \
        if(!(_cond)){                                   \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;               \
        }                                               \
     }                                                  \
     PPC_SET_LR(CPC+4);                                 \
     SET_TPC(CPC + SEXT16((BD<<2)));                    \
     if(_bflag) {										\
     	SET_NPC(CPC + SEXT16((BD<<2)));        			\
     	DEFTRACE(CPC + SEXT16((BD<<2)), "flow_altering");				\
     }													\
     else												\
     	DEFTRACE(CPC + sizeof(inst), "flow_altering");   /* jdonald uh oh */ \
   }
    
DEFINST(BCL,                   0x1,
        "bcl",                 "f,g,k",
        IntALU,                F_CTRL|F_COND|F_DIRJMP|F_CALL,
        PPC_DLR,PPC_DCNTR,     PPC_DCNTR,DNA,DNA,
	DNA, DNA, DNA,         DNA,DNA)	

#define BCA_IMPL                                        \
   {                                                    \
    word_t _ctr,_bflag=0,_cond;                          \
    _ctr= CNTR;                                         \
    if(!(0x4&BO)){                                      \
         _ctr=_ctr-1;                                   \
        PPC_SET_CNTR(_ctr);                             \
    }                                                   \
    _cond = (CR>>(31-BI))&0x1;                          \
                                                        \
     if(0x10&BO){                                       \
        if(0x14&BO) _bflag=1;                           \
        if( (0x12&BO) && (_ctr==0) ) _bflag=1;          \
        else if(_ctr!=0) _bflag=1;                      \
     }                                                  \
     else if(0x8&BO){                                   \
        if(_cond){                                      \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
     else{                                              \
        if(!(_cond)){                                   \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
     SET_TPC(SEXT16((BD<<2)));         	                \
     if(_bflag)  {										\
     	SET_NPC(SEXT16((BD<<2)));         				\
     	DEFTRACE(SEXT16((BD<<2)), "flow_altering");    	\
     }													\
     else												\
        DEFTRACE(CPC + sizeof(inst), "flow_altering");   /* jdonald uh oh */ \
   }
    
DEFINST(BCA,                   0x2,
        "bca",                 "f,g,k",
        IntALU,                F_CTRL|F_COND|F_DIRJMP,
        PPC_DCNTR,DNA,         PPC_DCNTR,DNA,DNA,
	DNA, DNA, DNA,         DNA,DNA)	


#define BCLA_IMPL                                       \
   {                                                    \
    word_t _ctr,_bflag=0,_cond;                          \
    _ctr= CNTR;                                         \
    if(!(0x4&BO)){                                      \
         _ctr=_ctr-1;                                   \
        PPC_SET_CNTR(_ctr);                             \
    }                                                   \
    _cond = (CR>>(31-BI))&0x1;                          \
                                                        \
     if(0x10&BO){                                       \
        if(0x14&BO) _bflag=1;                           \
        if( (0x12&BO) && (_ctr==0) ) _bflag=1;          \
        else if(_ctr!=0) _bflag=1;                      \
     }                                                  \
     else if(0x8&BO){                                   \
        if(_cond){                                      \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
     else{                                              \
        if(!(_cond)){                                   \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
     PPC_SET_LR(CPC+4);					\
     SET_TPC(SEXT16((BD<<2)));         	                \
     if(_bflag) {										\
     	SET_NPC(CPC + SEXT16((BD<<2)));        			\
     	DEFTRACE(CPC + SEXT16((BD<<2)), "flow_altering");				\
     }													\
     else												\
     	DEFTRACE(CPC + sizeof(inst), "flow_altering");   /* jdonald uh oh */ \
   }
    
DEFINST(BCLA,                  0x3,
        "bcla",                "f,g,k",
        IntALU,                F_CTRL|F_COND|F_DIRJMP|F_CALL,
        PPC_DLR,PPC_DCNTR,     PPC_DCNTR,DNA,DNA,
	DNA, DNA, DNA,         DNA,DNA)	




CONNECT(MCRF_LINK)

#define MCRF_IMPL                                                       \
   {                                                                    \
        word_t _a, _b, _c, _d;                                          \
        _c = CR;                                                        \
	_a = ( 0xf  << (( 7 - CRFS)*4) ) & CR;				\
	_a = (_c >> (( 7 - CRFS)*4)) & 0xf;					\
	_b = _a << (( 7 - CRFD)*4);					\
	_d = ( 0xf  << (( 7 - CRFD)*4) ) ;				\
        PPC_SET_CR( ((_c & ~(_d)) | _b ) );                                 \
   }

        

DEFINST(MCRF,                  0x0,
        "mcrf",                "r,w",
        IntALU,                F_ICOMP,
        PPC_DCR, DNA,          PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,         DNA, DNA)


#define CRNOR_IMPL	                                                \
   {                                                                    \
        word_t _a, _b, _c, _d, _m;                                \
        _c = CR;                                                        \
        _a = (0x1)  & (_c >> (31- CRBA));        \
        _b = (0x1)  & (_c >> (31- CRBB));        \
        _d = (!(_a | _b)) << (31-CRBD);				\
		  _m = ~(1 << (31-CRBD));							\
        PPC_SET_CR( ((_c & _m) | _d ) );                             \
   }
    
    
    
DEFINST(CRNOR,   	        0x42,
        "crnor",                "x,y,z",
        IntALU,                 F_ICOMP,
        PPC_DCR, DNA,           PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,        	DNA, DNA)


  


#define BCLR_IMPL                                       \
   {                                                    \
	 word_t nia;									\
	 word_t ctr_ok, cond_ok, _ctr, PC;										\
    _ctr= CNTR;                                         \
	 PC = CPC;															\
	 ctr_ok = 0; cond_ok = 0;									\
    if (DECREMENTS_CTR (inst)) {			\
        _ctr--;									\
        if (BR_IF_CTR_ZERO (inst)) {		\
				ctr_ok = (_ctr == 0);			\
        } else {									\
				ctr_ok = (_ctr != 0);			\
        }											\
    } else {										\
        ctr_ok = 1;								\
    }													\
    													\
    if (CONDITIONAL_BR (inst)) {				\
        if (BR_IF_TRUE (inst)) {				\
            cond_ok = (CR << GET_BI (inst)) & 0x80000000;		\
        } else {																\
            cond_ok = !((CR << GET_BI (inst)) & 0x80000000);	\
        }																		\
    } else {																	\
        cond_ok = 1;															\
    }																				\
																					\
    if (ctr_ok && cond_ok) {												\
       nia = LR & -4;														\
    } else {																	\
       nia = PC + sizeof(inst);											\
    }																				\
    if (GET_LK (inst))														\
    	LR = PC + sizeof(inst);													\
    SET_NPC(nia);																\
    DEFTRACE(nia, "flow_altering");											\
}

DEFINST(BCLR,                  0x20,
        "bclr",                "f,g",
        IntALU,                F_CTRL|F_COND|F_INDIRJMP,
        PPC_DCNTR,DNA,         PPC_DCNTR,PPC_DLR,DNA,
	DNA, DNA, DNA,         DNA,DNA)	

  


#define BCLRL_IMPL                                      \
   {                                                    \
    word_t _ctr,_bflag=0,_cond;                         \
    _ctr= CNTR;                                         \
    if(!(0x4&BO)){                                      \
         _ctr=_ctr-1;                                   \
        PPC_SET_CNTR(_ctr);                             \
    }                                                   \
    _cond = (CR>>(31-BI))&0x1;                          \
                                                        \
     if(0x10&BO){                                       \
        if(0x14&BO) _bflag=1;                           \
        if( (0x12&BO) && (_ctr==0) ) _bflag=1;          \
        else if(_ctr!=0) _bflag=1;                      \
     }                                                  \
     else if(0x8&BO){                                   \
        if(_cond){                                      \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
     else{                                              \
        if(!(_cond)){                                   \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
							\
    SET_TPC(LR &0xfffffffc);                            \
    if(_bflag) {										\
    	SET_NPC(LR &0xfffffffc);          			    \
    	DEFTRACE(LR &0xfffffffc, "flow_altering");      \
    }													\
	else												\
    	PPC_SET_LR(CPC+4);					\
        DEFTRACE(CPC + sizeof(inst), "flow_altering");  /* jdonald uh oh */ \
   }
    
DEFINST(BCLRL,                 0x21,
        "bclrl",               "f,g",  
        IntALU,                F_CTRL|F_COND|F_INDIRJMP|F_CALL,
        PPC_DCNTR,PPC_DLR,     PPC_DCNTR,PPC_DLR,DNA,
        DNA, DNA, DNA,         DNA, DNA)
  


#define CRANDC_IMPL                                                     \
   {                                                                    \
        word_t _a, _b, _c, _d, _m;		\
        _c = CR;                                                        \
        _a = (0x1) & (_c >> (31- CRBA));\
        _b = (0x1) & (_c >> (31- CRBB));\
		  _d = (_a & !_b) << (31-CRBD);\
		  _m = ~(1 << (31-CRBD));\
        PPC_SET_CR( ((_c & _m) | _d ) );                             \
   }
    


DEFINST(CRANDC,                 0x102,
        "crandc",               "x,y,z",
        IntALU,                 F_ICOMP,
        PPC_DCR, DNA,               PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,        	DNA, DNA)

#define ISYNC_IMPL                                              \
   {                                                            \
        EXEC_ISYNC;						\
   }

DEFINST(ISYNC,                  0x12C,
        "isync",                "",
        FUClass_NA,             F_MEM,
        DNA,DNA,                DNA,DNA,DNA,
        DNA, DNA, DNA,         	DNA, DNA)



#define CRXOR_IMPL                                                      \
   {                                                                    \
        word_t _a, _b, _c, _d,_m;                                       \
        _c = CR;                                                        \
        _a = (0x1)  & (_c >> (31- CRBA));     \
        _b = (0x1)  & (_c >> (31- CRBB));                  \
        _d = (_a ^ _b) <<(31-CRBD);                              \
		  _m = ~(1 << (31-CRBD));													\
        PPC_SET_CR( ((_c & _m) | _d ) );                    \
   }

        
        
DEFINST(CRXOR,                 	0x182,
        "crxor",               	"x,y,z",
        IntALU,                	F_ICOMP,
        PPC_DCR, DNA,          	PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,		DNA, DNA)

#define CRNAND_IMPL                                                     \
   {                                                                    \
        word_t _a, _b, _c, _d, _m;                                  \
        _c = CR;                                                        \
        _a = (0x1)  & (_c >> (31- CRBA));                    \
        _b = (0x1)  & (_c >> (31- CRBB));     \
		  _d = (!(_a & _b)) << (31-CRBD); \
		  _m = ~(0x1 << (31-CRBD));									\
        PPC_SET_CR( ((_c & _m) | _d ) );                             \
   }
  
  

DEFINST(CRNAND,                 0x1C2,
        "crnand",               "x,y,z",
        IntALU,                 F_ICOMP,
        PPC_DCR, DNA,           PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define CRAND_IMPL						\
   {								\
	word_t _a, _b, _c, _d, _m;					\
	_c = CR;						\
	_a = (0x1)  & (_c >> (31- CRBA));				\
	_b = (0x1)  & (_c >> (31- CRBB));				\
	_d = (_a & _b)<<(31-CRBD);				\
	_m = ~(1<<(31-CRBD));					\
	PPC_SET_CR( ((_c & _m) | _d ) );			\
   }



DEFINST(CRAND,			0x202,
	"crand",		"x,y,z",
	IntALU,			F_ICOMP,
	PPC_DCR, DNA,		PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,        	DNA, DNA)

#define CREQV_IMPL                                                      \
   {                                                                    \
        word_t _a, _b, _c, _d, _m;                                  \
        _c = CR;                                                        \
        _a = (0x1)  & (_c >> (31- CRBA));\
        _b = (0x1)  & (_c >> (31- CRBB));\
		  _d = (!(_a ^ _b)) << (31-CRBD);		\
		  _m = ~(0x1 << (31-CRBD));	\
        PPC_SET_CR( ((_c & _m) | _d ) );                             \
   }
    


DEFINST(CREQV,                  0x242,
        "creqv",                "x,y,z",
        IntALU,                 F_ICOMP,
        PPC_DCR, DNA,           PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,        	DNA, DNA)





  
#define CRORC_IMPL                                                      \
   {                                                                    \
        word_t _a, _b, _c, _d, _m;						\
        _c = CR;                                                        \
        _a = (0x1)  & (_c >> (31- CRBA));\
        _b = (0x1)  & (_c >> (31- CRBB));\
		  _d = (_a | (!_b)) << (31-CRBD);					\
		  _m = ~(0x1 << (31-CRBD));							\
		  PPC_SET_CR( (_c & _m) | _d );                             \
   }
        
        
    
DEFINST(CRORC,                  0x342,
        "crorc",                "x,y,z",
        IntALU,                 F_ICOMP,
        PPC_DCR, DNA,           PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define CROR_IMPL                                               \
   {                                                            \
        word_t _a, _b, _c, _d, _m;                                  \
        _c = CR;                                                \
        _a = (0x1)  & (_c >> (31- CRBA));			\
        _b = (0x1) & (_c >> (31- CRBB));\
        _d = (_a | _b)<<(31-CRBD);                              \
			_m = ~(1 << (31-CRBD));											\
        PPC_SET_CR( ((_c & _m) | _d ) );                     \
   }
    


DEFINST(CROR,                  0x382,
        "cror",                "x,y,z",
        IntALU,                F_ICOMP,
        PPC_DCR, DNA,          PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,         DNA, DNA)



#define BCCTR_IMPL                                      \
   {                                                    \
    word_t _ctr,_bflag=0,_cond;                          \
    _ctr= CNTR;                                         \
    if(!(0x4&BO)){                                      \
         _ctr=_ctr-1;                                   \
        PPC_SET_CNTR(_ctr);                             \
    }                                                   \
    _cond = (CR>>(31-BI))&0x1;                          \
                                                        \
     if(0x10&BO){                                       \
        if(0x14&BO) _bflag=1;                           \
        if( (0x12&BO) && (_ctr==0) ) _bflag=1;          \
        else if(_ctr!=0) _bflag=1;                       \
     }                                                  \
     else if(0x8&BO){                                   \
        if(_cond){                                      \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;               \
        }                                               \
     }                                                  \
     else{                                              \
        if(!(_cond)){                                   \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
     SET_TPC(CNTR &0xfffffffc);							\
     if(_bflag) {										\
     	SET_NPC(CNTR &0xfffffffc);         				\
     	DEFTRACE(CNTR &0xfffffffc, "flow_altering");	\
     }													\
     else												\
     	DEFTRACE(CPC + sizeof(inst), "flow_altering"); /* jdonald uh oh */  \
   }
    
DEFINST(BCCTR,                 0x420,
        "bcctr",               "f,g",
        IntALU,                F_CTRL|F_COND|F_INDIRJMP,
        DNA,DNA,               PPC_DCNTR,DNA,DNA,
	DNA, DNA, DNA,         DNA,DNA)	




#define BCCTRL_IMPL                                     \
   {                                                    \
    word_t _ctr,_bflag=0,_cond;                         \
    _ctr= CNTR;                                         \
    if(!(0x4&BO)){                                      \
         _ctr=_ctr-1;                                   \
        PPC_SET_CNTR(_ctr);                             \
    }                                                   \
    _cond = (CR>>(31-BI))&0x1;                          \
                                                        \
     if(0x10&BO){                                       \
        if(0x14&BO) _bflag=1;                           \
        if( (0x12&BO) && (_ctr==0) ) _bflag=1;          \
        else if(_ctr!=0) _bflag=1;                      \
     }                                                  \
     else if(0x8&BO){                                   \
        if(_cond){                                      \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
     else{                                              \
        if(!(_cond)){                                   \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
     PPC_SET_LR(CPC+4);					\
     SET_TPC(CNTR &0xfffffffc);                         \
     if(_bflag) {										\
     	SET_NPC(CNTR &0xfffffffc);         				\
     	DEFTRACE(CNTR &0xfffffffc, "flow_altering");	\
     }													\
     else												\
     	DEFTRACE(CPC + sizeof(inst), "flow_altering"); /* jdonald uh oh */  \
   }
        
DEFINST(BCCTRL,                0x421,
        "bcctrl",              "f,g",
        IntALU,                F_CTRL|F_COND|F_INDIRJMP|F_CALL,
        PPC_DLR,DNA,           PPC_DCNTR,DNA,DNA,
	DNA, DNA, DNA,         DNA,DNA)	




CONNECT(RLWIMI_LINK)

#define RLWIMI_IMPL							\
   {									\
	word_t _n, _r, _m;                                              \
   _m = sim_mask32(MB, ME);                         \
   _n = SH;                                     \
   _r = GPR(RS);                                     \
   _r = sim_rotate_left_32(_r, _n);                  \
	SET_GPR(RA, ( (_r & _m) | (GPR(RA) & (~ (_m))) ) );			\
   }

DEFINST(RLWIMI,				0x0,
	"rlwimi",			"a,s,h,m,e",
	IntALU,				F_ICOMP|F_IMM,
	PPC_DGPR(RA),DNA,		PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        		DNA, DNA)




#define RLWIMID_IMPL                                                    \
   {                                                                    \
        word_t _n, _r,_src, _m;                                              \
         _m = sim_mask32(MB, ME);                         \
         _n = SH;                                     \
         _r = GPR(RS);                                     \
         _r = sim_rotate_left_32(_r, _n);                  \
        _src = ( (_r & _m) | (GPR(RA) & (~ (_m))) );                    	\
	if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
        SET_GPR(RA, _src);                                              \
   }
    
DEFINST(RLWIMID,                0x1,
        "rlwimi.",              "a,s,h,m,e",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)

  



CONNECT(RLWINM_LINK)

#define RLWINM_IMPL                                                     \
   {                                                                    \
        word_t _n, _r, _m;                                              \
         _m = sim_mask32(MB, ME);                         \
         _n = SH;                                     \
         _r = GPR(RS);                                     \
         _r = sim_rotate_left_32(_r, _n);                  \
         _r = _r & _m;                                \
         SET_GPR(RA, _r);                             \
   }

DEFINST(RLWINM,                 0x0,
        "rlwinm",               "a,s,h,m,e",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)
        


#define RLWINMD_IMPL                                                    \
   {                                                                    \
        word_t _n, _r, _m, _src;                                        \
			_m = sim_mask32(MB, ME);									\
			_n = SH;													\
			_r = GPR(RS);													\
			_r = sim_rotate_left_32(_r, _n);						\
			_r = _r & _m;											\
			SET_GPR(RA, _r);										\
			_src = _r;											\
	/* definition has to be modified for 64bit machine */ \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }

DEFINST(RLWINMD,                0x1,
        "rlwinm.",              "a,s,h,m,e",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)




CONNECT(RLWNM_LINK)



#define RLWNM_IMPL                                                     	\
   {                                                                    \
        word_t _n, _r, _m;                                              \
        int _i, _c;                                                     \
        _n = GPR(RB) & 0x1F;						\
        _r = ((word_t)GPR(RS))<< _n;                                    \
        _c = ME-MB+1;                                                   \
        for(_i=0; _i<_c; _i++)                                          \
        {                                                               \
                _m = (_m <<1) | 0x1;                                    \
        }                                                               \
        _m = _m << (31-ME);                                             \
		  _m = (1 << (ME+1)) - (1 << MB);							\
        SET_GPR(RA,  (_r & _m) );                    			\
   }
        
DEFINST(RLWNM,                  0x0,
        "rlwnm",                "a,s,b,m,e",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define RLWNMD_IMPL                                                     \
   {                                                                    \
        word_t _n, _r, _m, _src;                                        \
        int _i, _c;                                                     \
        _n = GPR(RB)&0x1F;						\
        _r = ((word_t)GPR(RS))<< _n;                                    \
        _c = ME-MB+1;                                                   \
        for(_i=0; _i<_c; _i++)                                          \
        {                                                               \
                _m = (_m <<1) | 0x1;                                    \
        }                                                               \
        _m = _m << (31-ME);                                             \
        _src = ( (_r & _m) );                                           \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
        SET_GPR(RA, _src);                                              \
   }
        
DEFINST(RLWNMD,                 0x1,
        "rlwnm.",               "a,s,b,m,e",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)
   

CONNECT(B_LINK)

#define B_IMPL								\
   {									\
	SET_TPC( CPC + SEXT26(LI ) ); 					\
	SET_NPC( CPC + SEXT26(LI ) ); 					\
	DEFTRACE( CPC + SEXT26(LI ), "flow_altering"); \
   }

DEFINST(B,			0x0,
	"b",			"j",
	IntALU,			F_CTRL|F_UNCOND|F_DIRJMP,
	DNA,DNA,		DNA,DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)
		


#define BA_IMPL                                                         \
   {                                                                    \
        SET_TPC( SEXT26(LI) );     		                   	\
        SET_NPC( SEXT26(LI) );     		                   	\
		DEFTRACE( SEXT26(LI ), "flow_altering"); \
   }
                 
DEFINST(BA,                     0x2,
        "ba",                   "j",
        IntALU,                 F_CTRL|F_UNCOND|F_DIRJMP,
        DNA,DNA,                DNA,DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define BL_IMPL                                                         \
   {                                                                    \
        SET_TPC( CPC + SEXT26(LI ) );                                   \
        SET_NPC( CPC + SEXT26(LI ) );                                   \
		PPC_SET_LR( (CPC+4) );						\
		DEFTRACE( CPC + SEXT26(LI ), "flow_altering"); \
   }
                 
DEFINST(BL,                     0x1,
        "bl",                   "j",
        IntALU,                 F_CTRL|F_UNCOND|F_DIRJMP|F_CALL,
        PPC_DLR,DNA,            DNA,DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)

        
                
#define BLA_IMPL                                                        \
   {                                                                    \
	 SET_TPC( SEXT26(LI) );                                          \
	 SET_NPC( SEXT26(LI) );                                          \
	 PPC_SET_LR( (CPC+4) );						\
	 DEFTRACE( SEXT26(LI ), "flow_altering"); \
   }

DEFINST(BLA,                    0x3,
        "bla",                  "j",
        IntALU,                 F_CTRL|F_UNCOND|F_DIRJMP|F_CALL,
        PPC_DLR,DNA,            DNA,DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)

CONNECT(CMP_LINK)


#define CMP_IMPL							\
   {									\
	sword_t _a, _b;							\
	word_t _c;							\
	word_t _mask;							\
	if(ISSETL) {							\
		DECLARE_FAULT(md_fault_invalidinstruction);             \
	}								\
	else{								\
		_a = GPR(RA);						\
		_b = GPR(RB);						\
		if(_a<_b) _c=0x8;					\
		else{ 							\
                if (_a>_b) _c=0x4;				        \
			else	  _c=0x2;				\
		}							\
		_c = _c | (PPC_GET_XER_SO);			       	\
		_c = _c << ( (7-CRFD)*4 );				\
		_mask = ~( 0xf << 4 * (7 - CRFD));				\
		PPC_SET_CR( (CR & _mask)  | _c);					\
	}								\
   }


DEFINST(CMP,			0x0,
	"cmp",			"r,l,a,b",
	IntALU,			F_ICOMP,
	PPC_DCR, DNA,		PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
        DNA, DNA, DNA,         	PPC_DXER, DNA)



#define	TW_IMPL							\
   {								\
   	sword_t _sa, _sb;					\
   	word_t _a, _b;						\
	_sa = GPR(RA);						\
	_sb = GPR(RB);						\
	_a = (word_t)GPR(RA);					\
	_b = (word_t)GPR(RB);					\
	if( (_sa < _sb) && (TO & 0x10) ) 			\
	{							\
		TRAP;						\
	}							\
	else if( (_sa > _sb) && (TO & 0x8) )                    \
        {                                                       \
                TRAP;                                           \
        }							\
	else if( (_sa == _sb) && (TO & 0x4) )                   \
        {                                                       \
                TRAP;                                           \
        }							\
	else  if( (_a < _b) && (TO & 0x2) )                   	\
        {                                                       \
                TRAP;                                           \
        }                                                       \
        else if( (_a > _b) && (TO & 0x1) )                    	\
        {                                                       \
                TRAP;                                           \
        }                                                       \
   }

DEFINST(TW,			0x8,
	"tw",			"t,a,b",
	IntALU,             	F_RR,
        DNA,DNA,                PPC_DGPR(RA), PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,         	DNA, DNA)


#define SUBFC_IMPL                                                      \
  {                                                                     \
			word_t _r;																		\
			_r = GPR(RB) - GPR(RA);														\
			if (GPR(RA) == 0) PPC_SET_XER_CA; else { 					\
	        	if( carrygenerated( (sword_t)GPR(RB), (-(sword_t) GPR(RA)) )){\
   	      	PPC_SET_XER_CA;                     \
     	   	}                                           \
      	  		else { PPC_RESET_XER_CA;}                   \
			}															\
        SET_GPR(RD, GPR(RB) - GPR(RA) );									\
  }

DEFINST(SUBFC,                          0x10,
        "subfc",                        "d,a,b",
        IntALU,                         F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB),PPC_DXER,
        DNA, DNA, DNA,                  DNA, DNA)



#define SUBFCD_IMPL                                     \
  {                                                     \
    sword_t  _src;                                      \
    sword_t _ra,_rb;                                    \
    _ra = GPR(RA);                                      \
    _rb = GPR(RB);                                      \
                                                        \
    _src = _rb - _ra;               		        \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        SET_GPR(RD, _src);                              \
        if(carrygenerated(_rb, (-_ra) ) ){		\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
			if (_ra == 0) PPC_SET_XER_CA;							\
  }

DEFINST(SUBFCD,                 0x11,
        "subfc.",               "d,a,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), PPC_DCR,  PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER, 
        PPC_DXER,DNA,DNA,       DNA,DNA)



#define SUBFCO_IMPL                                     \
  {                                                     \
	sword_t _ra,_rb;                        	\
        _ra = GPR(RA);                 			\
        _rb = GPR(RB);                          	\
         if (UNDER(_rb, _ra)){                          \
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
        SET_GPR(RD, (_rb - _ra));                       \
        if(carrygenerated( _rb, (-_ra) ) ){             \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
			if (_ra == 0) PPC_SET_XER_CA;							\
  }

DEFINST(SUBFCO,                 	0x410,
        "subfco",               	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        DNA,DNA,DNA,            	DNA,DNA)
    

#define SUBFCOD_IMPL                                    \
  {                                                     \
        sword_t  _src;                                  \
   	sword_t _ra,_rb;                               	\
        _ra = GPR(RA);                                  \
        _rb = GPR(RB);                                  \
         if (UNDER(_rb, _ra)){                          \
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = _rb - _ra;                              \
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        if(carrygenerated(_rb, (- _ra) )){              \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
		  if (_ra == 0) PPC_SET_XER_CA;							\
  }
        
DEFINST(SUBFCOD,                	0x411,   
        "subfco.",              	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        PPC_DCR,DNA,DNA,            	PPC_DCR,DNA)
  

#define LWZX_IMPL                                                       \
   {                                                                    \
    word_t _result;                                                     \
    enum md_fault_type _fault;                                          \
    if(RA==0)                                                           \
        {                                                               \
           _result = READ_WORD(GPR(RB), _fault);                        \
         DEFTRACE(GPR(RB), "memory"); 		\
        }                                                               \
    else                                                                \
        {                                                               \
           _result = READ_WORD(GPR(RA)+GPR(RB), _fault);                \
           DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
        }                                                               \
        if (_fault != md_fault_none)                                    \
               DECLARE_FAULT(_fault);                                   \
        SET_GPR(RD, _result);                                           \
   }

DEFINST(LWZX,                   0x2E,
        "lwzx",                 "d,a,b",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RD),DNA,       DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)


#define MFCR_IMPL						\
   {								\
	SET_GPR(RD, CR);					\
   }


DEFINST(MFCR,			0x26,
	"mfcr",			"d",
	IntALU,			F_ICOMP,	
	PPC_DGPR(RD),DNA,	PPC_DCR,DNA,DNA,
        DNA, DNA, DNA,         	DNA, DNA)


#define LWARX_IMPL						\
   {								\
	word_t _result;						\
	enum md_fault_type _fault;				\
								\
     if(RA==0){							\
/*          _result = EXEC_LWARX(GPR(RB),_fault);	      */\
			DEFTRACE(GPR(RB), "memory"); /* jdonald no lwarx? */ \
        }							\
     else{							\
     /*     _result = EXEC_LWARX(GPR(RA) + GPR(RB), _fault);*/  \
            DEFTRACE(GPR(RA) + GPR(RB), "memory"); /* jdonald no lwarx? */ \
        }							\
        if (_fault != md_fault_none)				\
                DECLARE_FAULT(_fault);				\
        SET_GPR(RD, (word_t)_result);				\
   }

DEFINST(LWARX,                  0x28,
        "lwarx",                "d,a,b",
        IntALU,                 F_MEM,
        PPC_DGPR(RD),DNA,       DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)
 

#define CMPL_IMPL                                                       \
	{													\
    unsigned int compare;   					\
    unsigned int mask;							\
	 word_t ra, rb;								\
    if (0 == GET_L (inst)) {   				\
        /* 32-bit values */					\
		  ra = GPR(RA); rb = GPR(RB);			\
        if (ra > rb)								\
            compare = CR_GT_BIT;				\
        else if (ra < rb)						\
            compare = CR_LT_BIT;				\
        else										\
            compare = CR_EQ_BIT;				\
    } else {										\
        /* 64-bit values */					\
		 printf("STDOUT: ERROR!!! 64 bit unimplemented!\n");		\
		 exit(1);									\
    }													\
    /* compare = compare | P->xer.SO; */		\
    compare = compare | (PPC_GET_XER_SO);	\
    compare = compare << 4 * (7 - GET_BF(inst) );	\
    mask = ~( 0xf << 4 * (7 - GET_BF(inst) ));		\
    /* P->cr = ( P->cr & mask ) | compare; */	\
	 PPC_SET_CR( (CR & mask) | compare);	\
}

DEFINST(CMPL,                   0x40,
        "cmpl",                 "r,l,a,b",
        IntALU,                 F_ICOMP,
        PPC_DCR, DNA,           PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
        DNA, DNA, DNA,        	DNA, DNA)



#define DCBST_IMPL                                              \
   {                                                            \
	if(RA==0){						\
        	EXEC_DCBST(GPR(RB));                            \
			DEFTRACE(GPR(RB), "DCBx"); 		\
	}							\
	else{							\
        	EXEC_DCBST(GPR(RA)+GPR(RB));                    \
			DEFTRACE(GPR(RA) + GPR(RB), "DCBx"); 		\
	}							\
   }

DEFINST(DCBST,                  0x6C,
        "dcbst",                "a,b",
        IntALU, 	        F_RR,
        DNA,DNA,                PPC_DGPR(RA),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,         	DNA, DNA)


#define LWZUX_IMPL                                                      \
   {                                                                    \
    word_t _result;                                                     \
    enum md_fault_type _fault;                                          \
    if(RA==0||(RA==RD))                                                 \
        {                                                               \
           DECLARE_FAULT(md_fault_invalidinstruction);                  \
        }                                                               \
    else{                                                               \
           _result = READ_WORD(GPR(RA)+GPR(RB), _fault);                \
           DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
           if (_fault != md_fault_none)                                 \
                   DECLARE_FAULT(_fault);                               \
           SET_GPR(RD, _result);                                        \
           SET_GPR(RA, GPR(RA)+GPR(RB));                                \
        }                                                               \
   }
        
DEFINST(LWZUX,                          0x6E,
        "lwzux",                        "d,a,b",
        RdPort,                         F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RD),PPC_DGPR(RA),      DNA, PPC_DGPR(RA), DNA,
        DNA, DNA, DNA,                  DNA, DNA)


#define LBZX_IMPL							\
   {									\
     byte_t _result;                                                    \
     enum md_fault_type _fault;                                         \
                                                                        \
     if(RA==0){                                                         \
                _result = READ_BYTE(GPR(RB),_fault);                    \
         		DEFTRACE(GPR(RB), "memory"); 		\
        }                                                               \
     else{                                                              \
                 _result = READ_BYTE(GPR(RA) + GPR(RB), _fault);        \
         		DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
        }                                                               \
	if(_fault!=md_fault_none)                               	\
        	DECLARE_FAULT(_fault);                          	\
        SET_GPR(RD,(word_t)_result);                            	\
  }

DEFINST(LBZX,                   0xAE,
        "lbzx",                 "d,a,b",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RD),DNA,       DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)


#define DCBF_IMPL						\
   {								\
        if(RA==0){                                              \
         EXEC_DCBF(GPR(RB));				        \
		 DEFTRACE(GPR(RB), "DCBx"); 		\
       }                                                        \
       else{                                                    \
         EXEC_DCBF(GPR(RA)+GPR(RB));                            \
		 DEFTRACE(GPR(RA) + GPR(RB), "DCBx"); 		\
      }                                                         \
   }

DEFINST(DCBF,			0xAC,
	"dcbf",			"a,b",
	IntALU,			F_RR,
	DNA,DNA,		PPC_DGPR(RA),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,          DNA, DNA)



                

#define LBZUX_IMPL                                                      \
   {                                                                    \
     byte_t _result;                                                    \
     enum md_fault_type _fault;                                         \
                                                                        \
     if((RA==0)||(RA==RD)){                                             \
                DECLARE_FAULT(md_fault_invalidinstruction);             \
        }                                                               \
     else{                                                              \
                _result = READ_BYTE(GPR(RA) + GPR(RB), _fault);         \
         		DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
                if (_fault != md_fault_none)                            \
                DECLARE_FAULT(_fault);                                  \
                SET_GPR(RD, (word_t)_result);                           \
	 	SET_GPR(RA, GPR(RA) + GPR(RB));                        	\
        }                                                               \
   }

DEFINST(LBZUX,                          0xEE,
        "lbzux",                        "d,a,b",
        RdPort,                         F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RA),PPC_DGPR(RD),      DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,                  DNA, DNA)


#define MTCRF_IMPL                                              \
   {                                                            \
	word_t _m,_crm, _c, _a;					\
	int _i, _b, _d;							\
	_crm = CRM;						\
	_d = GPR(RS);					\
	for (_i = 0; _i < 8; _i++) {				\
		_b = (_crm >> _i) & 0x1;				\
		if (_b == 1) {						\
			_c = CR;							\
			_a = (_d >> (_i*4) ) & 0xf;	\
			_m = (0xf << ( (_i)*4) );			\
			PPC_SET_CR( (_c & ~_m) | (_a << ((_i)*4)) );		\
		}						\
	}							\
   }


DEFINST(MTCRF,                  0x120,   
        "mtcrf",                "R,s",   
        IntALU,                 F_ICOMP,
        PPC_DCR,DNA,           	PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,         	DNA, DNA)



#define STWCXD_IMPL                                             \
   {                                                            \
        word_t _result, _cr0;					\
        enum md_fault_type _fault;                              \
                                                                \
     if(RA==0){                                                 \
     /*                _result = EXEC_STWCXD(GPR(RS),GPR(RB),_fault, _cr0);*/ \
			DEFTRACE(GPR(RB), "memory"); 	/* jdonald stwcxd? */	\
        }                                                       \
     else{                                                      \
     /*  _result = EXEC_STWCXD(GPR(RS),GPR(RA) + GPR(RB),_fault,_cr0);*/\
			 DEFTRACE(GPR(RA) + GPR(RB), "memory"); /* jdonald stwcxd? */ 		\
        }                                                       \
        if (_fault != md_fault_none)                            \
                DECLARE_FAULT(_fault);                          \
        SET_GPR(RS, (word_t)_result);                           \
	PPC_SET_CR((CR&0x0fffffff)|(_cr0<<28));			\
   }

DEFINST(STWCXD,                 0x12D,
        "stwcx.",               "s,a,b",
        IntALU,                 F_MEM,
        PPC_DCR,DNA,   PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          PPC_DCR, DNA)


#define STWX_IMPL                                                       \
   {                                                                    \
    word_t _src;                                                        \
    enum md_fault_type _fault;                                          \
    _src = (word_t)GPR(RS);                                     	\
                                                                        \
    if(RA==0){                                                          \
            WRITE_WORD(_src, GPR(RB), _fault);                          \
			 DEFTRACE(GPR(RB), "memory"); 		\
        }                                                               \
    else{                                                               \
            WRITE_WORD(_src, GPR(RA) + GPR(RB), _fault);                \
			DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
        }                                                               \
    if (_fault != md_fault_none)                                        \
           DECLARE_FAULT(_fault);                                       \
   }

DEFINST(STWX,                  0x12E,
        "stwx",                "s,a,b",
        WrPort,                F_MEM|F_STORE|F_RR,
        DNA,DNA,               PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,         DNA, DNA)


#define STWUX_IMPL                                                      \
   {                                                                    \
    word_t _src;                                                        \
    enum md_fault_type _fault;                                          \
                                                                        \
    if(RA==0){                                                          \
                 DECLARE_FAULT(md_fault_invalidinstruction);            \
        }                                                               \
    else{                                                               \
            _src = (word_t)GPR(RS);                             	\
            WRITE_WORD(_src, GPR(RA) + GPR(RB), _fault);                \
			DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
            if (_fault != md_fault_none)                                \
                DECLARE_FAULT(_fault);                                  \
             SET_GPR(RA, GPR(RA)+GPR(RB));                              \
        }                                                               \
   }

DEFINST(STWUX,                  0x16E,
        "stwux",                "s,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)

#define STBX_IMPL                                                       \
   {                                                                    \
        byte_t  _src;                                                   \
        enum md_fault_type _fault;                                      \
        _src=(byte_t)(word_t)GPR(RS);                                   \
        if(RA==0){                                                      \
                 WRITE_BYTE(_src, GPR(RB), _fault);                     \
			 	DEFTRACE(GPR(RB), "memory"); 		\
        }                                                               \
        else{                                                           \
             WRITE_BYTE( _src, GPR(RA)+GPR(RB), _fault);                \
			 DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
        }                                                               \
        if (_fault != md_fault_none)                                    \
                DECLARE_FAULT(_fault);                                  \
   }
   
DEFINST(STBX,                   0x1AE,
        "stbx",                 "s,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        DNA,DNA,                PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)
 

#define DCBTST_IMPL                                             \
   {                                                            \
	if(RA==0){						\
	        EXEC_DCBTST(GPR(RB));                           \
			DEFTRACE(GPR(RB), "DCBx"); 		\
	}							\
	else{	        					\
		EXEC_DCBTST(GPR(RA)+GPR(RB));                   \
		DEFTRACE(GPR(RA) + GPR(RB), "DCBx"); 		\
	}							\
   }
        
DEFINST(DCBTST,                 0x1EC,
        "dcbtst",               "a,b",
        IntALU,             	F_RR,
        DNA, DNA,               PPC_DGPR(RA),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,          DNA, DNA)



#define STBUX_IMPL                                                      \
   {                                                                    \
        byte_t  _src;                                                   \
        enum md_fault_type _fault;                                      \
        if(RA==0){                                                      \
                 DECLARE_FAULT(md_fault_invalidinstruction);            \
        }                                                               \
        else{                                                           \
             _src=(byte_t)(word_t)GPR(RS);                              \
             WRITE_BYTE( _src, GPR(RA)+GPR(RB), _fault);                \
			 DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
             if (_fault != md_fault_none)                               \
                DECLARE_FAULT(_fault);                                  \
		SET_GPR(RA, GPR(RA)+GPR(RB));                           \
        }                                                               \
   }

DEFINST(STBUX,                  0x1EE,
        "stbux",                "s,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)


#define DCBT_IMPL                                               \
   {                                                            \
	if(RA==0){						\
        	EXEC_DCBT(GPR(RB));                             \
			DEFTRACE(GPR(RB), "DCBx"); 		\
	}							\
	else{        						\
		EXEC_DCBT(GPR(RA)+GPR(RB));                     \
		DEFTRACE(GPR(RA) + GPR(RB), "DCBx"); 		\
	}							\
   }

DEFINST(DCBT,                   0x22C,
        "dcbt",                 "a,b",
        IntALU,             	F_RR,
        DNA,DNA,                PPC_DGPR(RA),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,          DNA, DNA)

   


#define LHZX_IMPL                                                       \
   {                                                                    \
    half_t _result;                                                     \
    enum md_fault_type _fault;                                          \
    if(RA==0)                                                           \
        {                                                               \
           _result = READ_HALF(GPR(RB), _fault);                        \
           DEFTRACE(GPR(RB), "memory"); 		\
        }                                                               \
    else                                                                \
        {                                                               \
           _result = READ_HALF(GPR(RA)+GPR(RB), _fault);                \
           DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
        }                                                               \
        if (_fault != md_fault_none)                                    \
                DECLARE_FAULT(_fault);                                  \
        SET_GPR(RD, (word_t)_result);                                   \
   }


DEFINST(LHZX,                   0x22E,
        "lhzx",                 "d,a,b",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RD),DNA,       DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)


#define ECIWX_IMPL                                              \
   {                                                            \
        word_t _result;                                         \
        enum md_fault_type _fault;                              \
                                                                \
     if(RA==0){                                                 \
 /*               _result = EXEC_ECIWX(GPR(RB),_fault);       */    \
 	    DEFTRACE(GPR(RB), "memory"); /* jdonald eciwx? */ 		\
     }                                                       \
     else{                                                      \
     /*              _result = EXEC_ECIWX(GPR(RA) + GPR(RB), _fault);*/\
         DEFTRACE(GPR(RA) + GPR(RB), "memory"); /* jdonald eciwx? */ 		\
        }                                                       \
        if (_fault != md_fault_none)                            \
                DECLARE_FAULT(_fault);                          \
        SET_GPR(RD, (word_t)_result);                           \
   }


DEFINST(ECIWX,                  0x26C, 
        "eciwx",                "d,a,b",
        IntALU,                 F_MEM,
        PPC_DGPR(RD),DNA,       PPC_DGPR(RA),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,         	DNA, DNA)





#define LHZUX_IMPL                                                      \
   {                                                                    \
    half_t _result;                                                     \
    enum md_fault_type _fault;                                          \
    if(RA==0||(RA==RD))                                                 \
        {                                                               \
           DECLARE_FAULT(md_fault_invalidinstruction);                  \
        }                                                               \
    else                                                                \
        {                                                               \
           _result = READ_HALF(GPR(RA)+GPR(RB), _fault);                \
           DEFTRACE(GPR(RA) + GPR(RB), "memory"); /* jdonald alignment? */ 		\
           if (_fault != md_fault_none)                                 \
                DECLARE_FAULT(_fault);                                  \
           SET_GPR(RD, (word_t)_result);	                        \
           SET_GPR(RA, GPR(RA)+GPR(RB));                                \
        }                                                               \
   }

DEFINST(LHZUX,                          0x26E,
        "lhzux",                        "d,a,b",
        RdPort,                         F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RD),PPC_DGPR(RA),      DNA, PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,                  DNA, DNA)

/*FixMe: What to do with the error handler here */

#define MFSPR_IMPL                                              \
   {                                                            \
	word_t _s, _d;						\
	_s = SPR;						\
	_d = (_s & 0x1F) + (( _s >> 5)&0x1F);			\
	if (_d ==1)						\
	{							\
		SET_GPR(RD, XER);				\
	}							\
	else if (_d ==8)                                        \
        {                                                       \
                SET_GPR(RD, LR); 	                        \
        }                                                       \
        else if (_d == 9)                                       \
        {                                                       \
                SET_GPR(RD, CNTR);                              \
        }                                                       \
	else{							\
	/*Error handler is invoked here*/			\
	}                                                       \
   }
        
    
DEFINST(MFSPR,                 0x2A6,
        "mfspr",               "d,P",
        IntALU,                F_ICOMP, 
        PPC_DGPR(RD),DNA,      PPC_DXER_LR_CNTR(SPRVAL),DNA,DNA,
        DNA, DNA, DNA,         DNA, DNA)




#define LHAX_IMPL                                                      	\
   {                                                                    \
    shalf_t _result;                                                    \
    enum md_fault_type _fault;                                          \
    if(RA==0){                                              		\
	 _result = READ_HALF(GPR(RB), _fault);                  	\
     DEFTRACE(GPR(RB), "memory"); 		\
    }                                                               \
    else{                                                               \
        _result = READ_HALF(GPR(RA)+GPR(RB), _fault);                   \
         DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
        }                                                               \
	if (_fault != md_fault_none)                                	\
		DECLARE_FAULT(_fault);                                  \
        SET_GPR(RD, (word_t)(sword_t)_result);                       	\
   }

DEFINST(LHAX,                   0x2AE,
        "lhax",                 "d,a,b",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RD),DNA,       DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)

#define MFTB_IMPL { \
        word_t _n ; \
        _n = ((RB << 5) | RA) ; \
        if (_n == 268) { \
                SET_GPR(RD, (TBR & ULL(0x00000000ffffffff))) ; \
        } \
        else if (_n == 269) { \
                SET_GPR(RD, ((TBR & ULL(0xffffffff00000000)) >> 32)) ; \
        } \
        else { \
                panic ("Incorrect value for tbr.\n") ; \
        } \
}

DEFINST(MFTB, 0x2E6, 
        "mftb", "t", IntALU, F_ICOMP,
        PPC_DGPR(RD), DNA,      DNA, DNA, DNA,
        DNA, DNA, DNA,          DNA, DNA)

#define LHAUX_IMPL                                                      \
   {                                                                    \
    shalf_t _result;                                                    \
    enum md_fault_type _fault;                                          \
    if((RA==0)||(RA==RD)){                                              \
                DECLARE_FAULT(md_fault_invalidinstruction);             \
        }                                                               \
    else{                                                               \
        _result = READ_HALF(GPR(RA)+GPR(RB), _fault);                   \
        DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
            if (_fault != md_fault_none)                                \
                DECLARE_FAULT(_fault);                                  \
           SET_GPR(RD, (word_t)(sword_t)_result);                       \
           SET_GPR(RA, GPR(RA) + GPR(RB));                              \
        }                                                               \
   }
        

DEFINST(LHAUX,                          0x2EE,
        "lhaux",                        "d,a,b",
        RdPort,                         F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RD),PPC_DGPR(RA),      DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,                  DNA, DNA)

#define STHX_IMPL                                                      	\
   {                                                                    \
    half_t _src;                                                        \
    enum md_fault_type _fault;                                          \
    _src = (half_t)(word_t)GPR(RS);                             	\
                                                                        \
    if(RA==0){                                                          \
            WRITE_HALF(_src, GPR(RB), _fault);                		\
			DEFTRACE(GPR(RB), "memory"); 		\
        }                                                               \
    else{                                                               \
            WRITE_HALF(_src, GPR(RA) + GPR(RB), _fault);                \
			DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
        }                                                               \
    if (_fault != md_fault_none)                                	\
           DECLARE_FAULT(_fault);                                  	\
   }

DEFINST(STHX,                  0x32E,
        "sthx",                "s,a,b",
        WrPort,                F_MEM|F_STORE|F_RR,
        DNA,DNA,               PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,         DNA, DNA)        

/*FixMe: The functional unit class and the instruction unit flags
need to be checked*/
   



#define ECOWX_IMPL                                              \
   {                                                            \
        word_t _result;                                         \
        enum md_fault_type _fault;                              \
                                                                \
     if(RA==0){                                                 \
/*                _result = EXEC_ECOWX(GPR(RS),GPR(RB),_fault);*/\
         		DEFTRACE(GPR(RB), "memory"); /* jdonald ecowx? */		\
        }                                                       \
     else{                                                      \
  /*               _result = EXEC_ECOWX(GPR(RS),GPR(RA) + GPR(RB),_fault);*/\
         		DEFTRACE(GPR(RA) + GPR(RB), "memory"); 	/* jdonald ecowx? */	\
        }                                                       \
        if (_fault != md_fault_none)                            \
                DECLARE_FAULT(_fault);                          \
        SET_GPR(RS, (word_t)_result);                           \
   }    
  
DEFINST(ECOWX,                  0x36C,
        "ecowx",                "s,a,b",
        IntALU,                 F_MEM,
        DNA, DNA,               PPC_DGPR(RA),PPC_DGPR(RB),PPC_DGPR(RS),
        DNA, DNA, DNA,          DNA, DNA)

    
    

#define STHUX_IMPL                                                      \
   {                                                                    \
    half_t _src;                                                        \
    enum md_fault_type _fault;                                          \
                                                                        \
    if(RA==0){                                                          \
                 DECLARE_FAULT(md_fault_invalidinstruction);            \
        }                                                               \
    else{                                                               \
            _src = (half_t)(word_t)GPR(RS);                             \
            WRITE_HALF(_src, GPR(RA) + GPR(RB), _fault);                \
			DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
            if (_fault != md_fault_none)                                \
                DECLARE_FAULT(_fault);                                  \
	     SET_GPR(RA, GPR(RA)+GPR(RB));				\
        }                                                               \
   }
        
DEFINST(STHUX,                  0x369,
        "sthux",                "s,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)

/*FixMe: What to do with the error handler here */

#define MTSPR_IMPL                                              \
   {                                                            \
        word_t _s, _d;                                          \
        _s = SPR;                                               \
        _d = (_s & 0x1f) + (( _s >> 5)&0x1F);                    \
        if (_d ==1)                                             \
        {                                                       \
                PPC_SET_XER(GPR(RD));                       \
        }                                                       \
        else if (_d ==8)                                        \
        {                                                       \
                PPC_SET_LR(GPR(RD));                        \
        }                                                       \
        else if (_d == 9)                                       \
        {                                                       \
                PPC_SET_CNTR(GPR(RD));                      \
        }                                                   \
        else{                                               \
        /*Error handler is invoked here*/                   \
        }                                                   \
   }
    
    
DEFINST(MTSPR,                          0x3A6,
        "mtspr",                        "p, s",
        IntALU,                         F_ICOMP,  
        PPC_DXER_LR_CNTR(SPRVAL), DNA,	PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,                  DNA, DNA)


#define SYNC_IMPL                                               \
   {                                                            \
        EXEC_SYNC;                                              \
   }


DEFINST(SYNC,                  0x4AC,
        "sync",                "",
        FUClass_NA,            F_MEM,
        DNA,DNA,               DNA,DNA,DNA,
        DNA, DNA, DNA,         DNA, DNA)





#define MCRXR_IMPL                                              \
   {                                                            \
	word_t _src, _m, _c;					\
	_src = (XER >> 28) & 0xf;				\
	_src = _src << ( (7-CRFD)*4 );				\
	PPC_SET_XER(XER & 0x0fffffff);				\
	_m = 0xf << ( (7-CRFD)*4 );				\
	_c = CR;						\
	PPC_SET_CR( (_c & (~(_m))) | _src );			\
   }
        
DEFINST(MCRXR,                  0x400,
        "mcrxr",                "r",
        IntALU,                 F_ICOMP,
        PPC_DCR,PPC_DXER,      	PPC_DCR,PPC_DXER,DNA,
        DNA, DNA, DNA,         	DNA, DNA)



#define LSWX_IMPL                               \
   {                                            \
        sword_t _ea;                            \
        word_t _n, _r,_i, _val;                 \
        byte_t _result;                         \
        enum md_fault_type _fault;              \
        if(RA==0){                              \
                _ea=GPR(RB);                    \
        }                                       \
        else _ea= GPR(RA)+GPR(RB);              \
                                                \
        _n = XER & 0xff;     	                \
                                                \
        _r=RD;                                  \
        _i = 0;                                 \
		  SET_GPR(_r, 0x0);								\
		DEFTRACE(_ea, "memory_extended"); 		\
		DEFTRACE(_n * 4, "memory_extended"); /* jdonald bytes or words? hmm. */ \
        while(_n>0){                            \
                if(_i==32){                     \
                        _r = (_r+1)%32;         \
                        SET_GPR(_r,0x0);        \
                        _i=0;                   \
                }                               \
        	_val=GPR(_r);                           \
        	 _result = READ_BYTE(_ea, _fault);      \
        	if (_fault != md_fault_none)            \
               DECLARE_FAULT(_fault);           \
        	_val = _val |( ((word_t)_result)<<( 24 - _i));\
        	SET_GPR(_r,_val);                       \
        	_i=_i+8;                                \
        	_ea++;                                  \
        	_n--;                                   \
        }                                       \
   }

DEFINST(LSWX,                   0x42A,
        "lswx",                 "d,a,b",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        DNA,DNA,                DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA,DNA,DNA,        PPC_DXER,DNA)


#define LWBRX_IMPL                                                      \
   {                                                                    \
     byte_t _src1, _src2, _src3, _src4;                                 \
     enum md_fault_type _fault;                                         \
     sword_t _ea;							\
     if(RA==0){                                                         \
	_ea= GPR(RB);							\
        }                                                               \
     else{                                                              \
	_ea=GPR(RA)+GPR(RB);						\
	}								\
        _src1 = READ_BYTE(_ea, _fault);                     		\
        DEFTRACE(_ea, "memory"); /* jdonald alignment? */ \
     if (_fault != md_fault_none)                                       \
           DECLARE_FAULT(_fault);                                       \
        _src2 = READ_BYTE(_ea+1, _fault);                   		\
     if (_fault != md_fault_none)                                       \
           DECLARE_FAULT(_fault);                                       \
        _src3 = READ_BYTE(_ea+2, _fault);                   		\
     if (_fault != md_fault_none)                                       \
           DECLARE_FAULT(_fault);                                       \
        _src4 = READ_BYTE(_ea+3, _fault);                   		\
     if (_fault != md_fault_none)                                       \
           DECLARE_FAULT(_fault);                                       \
                                                                   \
     SET_GPR(RD,( ((word_t)_src1) || (((word_t)_src2) << 8) || (((word_t)_src3) << 16) || (((word_t)_src3) << 24) ) ); \
   }    

DEFINST(LWBRX,                  0x42C,
        "lwbrx",                "d,a,b",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RD),DNA,       DNA, PPC_DGPR(RA),PPC_DGPR(RA),
        DNA, DNA, DNA,          DNA, DNA)

#define LFSX_IMPL                                                       \
   {                                                                    \
     word_t _result;                                                    \
     enum md_fault_type _fault;                                         \
     dfloat_t _da;							\
     if(RA==0){                                                         \
                _result = READ_WORD(GPR(RB),_fault);			\
    			DEFTRACE(GPR(RB), "memory"); 		\
        }                                                               \
     else{                                                              \
                 _result = READ_WORD(GPR(RA) + GPR(RB), _fault);		\
    			DEFTRACE(GPR(RA) + GPR(RB), "memory"); 					\
        }                                                               \
                if (_fault != md_fault_none)                            \
                DECLARE_FAULT(_fault);                                  \
                _da =(dfloat_t)( *((sfloat_t*)(&_result)));             \
                PPC_SET_FPR_D(RD, _da);                                 \
   }


DEFINST(LFSX,                   0x42E,
        "lfsx",                 "D,a,b",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        PPC_DFPR(FD),DNA,       DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)


#define LFSUX_IMPL                                                      \
   {                                                                    \
     word_t _result;                                                    \
     enum md_fault_type _fault;                                         \
     dfloat_t _da;							\
     if(RA==0){                                                         \
                DECLARE_FAULT(md_fault_invalidinstruction);             \
     }                                                                  \
     else{                                                              \
                _result = READ_WORD(GPR(RA) + GPR(RB), _fault);         \
         		DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
                if (_fault != md_fault_none)                            \
                DECLARE_FAULT(_fault);                                  \
		_da =(dfloat_t)( *((sfloat_t*)(&_result)));		\
        	PPC_SET_FPR_D(RD, _da);                                	\
                SET_GPR(RA, GPR(RA) + GPR(RB));                         \
        }                                                               \
   }
                 
DEFINST(LFSUX,                          0x46E,
        "lfsux",                        "D,a,b",
        RdPort,                         F_MEM|F_LOAD|F_RR,
        PPC_DFPR(FD),PPC_DGPR(RA),     DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,                  DNA, DNA)

#define LSWI_IMPL				\
   {						\
	sword_t _ea;				\
	word_t _n, _r,_i, _val;			\
	byte_t _result;				\
    	enum md_fault_type _fault;		\
	if(RA==0){				\
		_ea=0;				\
	}					\
	else _ea= GPR(RA);			\
						\
	if(NB==0) _n = 32;			\
	else _n=NB;				\
						\
	_r=RD;					\
	_i = 0;					\
	SET_GPR(_r, 0);		\
    DEFTRACE(_ea, "memory"); 		\
    while(_n>0){				\
		if(_i==32){			\
			_r = (_r+1)%32;		\
			SET_GPR(_r,0x0);	\
			_i=0;			\
		}				\
		_val=GPR(_r);				\
    	_result = READ_BYTE(_ea, _fault);	\
    	if (_fault != md_fault_none)	{	\
           DECLARE_FAULT(_fault);		\
		} 						\
		_val = _val |( ((word_t)_result)<<( 24 - _i));\
		SET_GPR(_r,_val);			\
		_i=_i+8;				\
		_ea++;					\
		_n--;					\
	}					\
   }

DEFINST(LSWI,                   0x4AA,
        "lswi",                 "d,a,N",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        DNA,DNA,                DNA, PPC_DGPR(RA),DNA,
        DNA,DNA,DNA,    DNA,DNA)


#define LFDX_IMPL                                                       \
  {                                                                     \
    enum md_fault_type _fault;                                          \
    sword_t _ea;							\
    qword_t _res;                           \
    word_t _a1, _a2;                        \
    if(RA==0) _ea = GPR(RB);                                            \
    else      _ea = GPR(RA) + GPR(RB);                             	\
    /* _res = READ_QWORD(_ea, _fault); */                     \
    _a1 = READ_WORD(_ea, _fault); _a2 = READ_WORD(_ea+4, _fault); \
    _res = _a2 | ((qword_t) _a1) << 32; \
    if (_fault != md_fault_none)                                        \
      DECLARE_FAULT(_fault);                                            \
    PPC_SET_FPR_DW(FD, _res);                                               \
  }
   
DEFINST(LFDX,                   0x4AE,
        "lfdx",                 "D,a,b",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        PPC_DFPR(FD), DNA,      DNA, PPC_DGPR(RA), PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)

#define LFDUX_IMPL                                                      \
  {                                                                     \
    enum md_fault_type _fault;                                          \
    sword_t _ea;   							\
    qword_t _res;                                                 	\
    word_t _a1, _a2; \
    if(RA==0){                                                          \
                DECLARE_FAULT(md_fault_invalidinstruction);             \
     }                                                                  \
    else{                                                               \
                _ea = GPR(RA) + GPR(RB);                           	\
    /* _res = READ_QWORD(_ea, _fault);            */        \
    _a1 = READ_WORD(_ea, _fault); _a2 = READ_WORD(_ea+4, _fault); \
    DEFTRACE(_ea, "memory"); /* jdonald alignment? */		\
    _res = _a2 | ((qword_t) _a1) << 32; \
    if (_fault != md_fault_none)                            \
    	DECLARE_FAULT(_fault);                          \
    PPC_SET_FPR_DW(FD, _res);                               \
    SET_GPR(RA,_ea);                                        \
    }                                                               \
  }

DEFINST(LFDUX,                          0x4EE,
        "lfdux",                        "D,a,b",
        RdPort,                         F_MEM|F_LOAD|F_RR,
        PPC_DFPR(FD), PPC_DGPR(RA),     DNA, PPC_DGPR(RA), PPC_DGPR(RB),
        DNA, DNA, DNA,                  DNA, DNA)

#define STSWX_IMPL                              \
   {                                            \
        sword_t _ea;                            \
        word_t _n, _r,_i, _val;                 \
        byte_t _result;                         \
        enum md_fault_type _fault;              \
        if(RA==0){                              \
                _ea=GPR(RB);                    \
        }                                       \
        else _ea= GPR(RA)+GPR(RB);              \
                                                \
        _n = XER & 0xff;                	\
                                                \
        _r=RD;                                  \
        _i = 0;                                 \
		DEFTRACE(_ea, "memory_extended"); 		\
		DEFTRACE(_n * 4, "memory_extended"); /* jdonald bytes or words? hmm. */ \
        while(_n>0){                            \
                if(_i==32){                     \
                        _r = (_r+1)%32;         \
                        _i=0;                   \
                }                               \
        _val = GPR(_r);                         \
        _result =(byte_t)( 0xff & (_val>>(24-_i)) );\
        WRITE_BYTE(_result, _ea, _fault);       \
        if (_fault != md_fault_none)            \
               DECLARE_FAULT(_fault);           \
        _i=_i+8;                                \
        _ea++;                                  \
        _n--;                                   \
        }                                       \
   }

DEFINST(STSWX,                  0x52A,
        "stswx",                "s,a,N",
        WrPort,                 F_MEM|F_STORE|F_RR,
        DNA,DNA,                PPC_DGPR(RS), PPC_DGPR(RA),DNA,
        DNA,DNA,DNA,            PPC_DXER, DNA )

#define STWBRX_IMPL                                                     \
   {                                                                    \
    word_t _src;                                                        \
    enum md_fault_type _fault;                                          \
    byte_t _src1, _src2, _src3, _src4;                                  \
    _src1 =(byte_t)( (word_t)(GPR(RS)) & 0xff );                        \
    _src2 =(byte_t)( ((word_t)(GPR(RS)) & 0xff00)>>8 );                 \
    _src3 =(byte_t)( ((word_t)(GPR(RS)) & 0xff0000)>>16 );              \
    _src4 =(byte_t)( ((word_t)(GPR(RS)) & 0xff000000)>>24 );            \
    _src = (((word_t)_src1)<<24) || (((word_t)_src2)<<16) || (((word_t)_src3)<<8) || ((word_t)_src4);\
    if(RA==0){                                                          \
                WRITE_WORD( _src, GPR(RB), _fault);                     \
			 	DEFTRACE(GPR(RB), "memory"); 		\
        }                                                               \
    else{                                                               \
                WRITE_WORD( _src, GPR(RA)+GPR(RB), _fault);             \
			    DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
    }                                                                   \
    if (_fault != md_fault_none)                            		\
	    DECLARE_FAULT(_fault);                          		\
  }

DEFINST(STWBRX,                 0x52C,
        "stwbrx",               "s,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        DNA,DNA,                PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)

#define STFSX_IMPL                                                      \
   {                                                                    \
   enum md_fault_type _fault;                                      \
   float tempf;            \
   word_t *ptempf;         \
   double double_a;		\
   qword_t _d =PPC_FPR_DW(FS);      \
   memcpy(&double_a, &_d, sizeof(double) ); \
   tempf = (float) double_a;                       \
   ptempf = (word_t *) (&tempf);    \
   if(RA==0){                    \
      WRITE_WORD(*ptempf, GPR(RA), _fault);   \
	  DEFTRACE(GPR(RB), "memory"); 		\
   }                    \
   else{                      \
      WRITE_WORD(*ptempf, GPR(RA)+GPR(RB), _fault);\
	  DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
   }                                                     \
   if (_fault != md_fault_none)                                \
      DECLARE_FAULT(_fault);                                  \
}         

DEFINST(STFSX,                  0x52E,
        "stfsx",                "S,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        DNA,DNA,                PPC_DFPR(FS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)

#define STFSUX_IMPL                                                     \
 {                                                                    \
   enum md_fault_type _fault;                                      \
   float tempf;            \
   word_t *ptempf;         \
   double double_a;             \
   qword_t _d =PPC_FPR_DW(FS);      \
   memcpy(&double_a, &_d, sizeof(double) ); \
   tempf = (float) double_a;                       \
   ptempf = (word_t *) (&tempf);    \
   WRITE_WORD(*ptempf, GPR(RA)+GPR(RB), _fault);\
   DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
   if (_fault != md_fault_none)                                \
      DECLARE_FAULT(_fault);                                  \
	SET_GPR( RA, GPR(RA) + GPR(RB) );									\
} 

DEFINST(STFSUX,                 0x56E,
        "stfsux",               "S,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        PPC_DGPR(RA),DNA,       PPC_DFPR(FS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)


#define STSWI_IMPL                              \
   {                                            \
        sword_t _ea;                            \
        word_t _n, _r,_i, _val;                 \
        byte_t _result;                         \
        enum md_fault_type _fault;              \
        if(RA==0){                              \
                _ea=0;                          \
        }                                       \
        else _ea= GPR(RA);                      \
                                                \
        if(NB==0) _n = 32;                      \
        else _n=NB;                             \
                                                \
        _r=RD;                                  \
        _i = 0;                                 \
       	DEFTRACE(_ea, "memory"); 		\
       	while(_n>0){                            \
                if(_i==32){                     \
                        _r = (_r+1)%32;         \
                        _i=0;                   \
                }                               \
        	_val = GPR(_r);                         \
			_result =(byte_t)( 0xff & (_val>>(24-_i)) );\
        	WRITE_BYTE(_result, _ea, _fault);      	\
        	if (_fault != md_fault_none) {            \
               DECLARE_FAULT(_fault);           \
			}												\
	        _i=_i+8;                                \
        	_ea++;                                  \
        	_n--;                                   \
        }                                       \
   }

DEFINST(STSWI,                  0x5AA,
        "stswi",                "s,a,N",
        WrPort,                 F_MEM|F_STORE|F_RR,
        DNA,DNA,                PPC_DGPR(RS), PPC_DGPR(RA),DNA,
        DNA,DNA,DNA,            DNA, DNA )



#define STFDX_IMPL                                                      \
{                                                                    \
	enum md_fault_type _fault;                                      \
	sword_t _ea;							\
	if(RA==0){                                                      \
		_ea=GPR(RB);					\
	}                                                       \
	else{                                                           \
		_ea=GPR(RA)+GPR(RB);					\
	} 								\
	WRITE_WORD((PPC_FPR_UW(FS)), _ea, _fault);			\
	DEFTRACE(_ea, "memory"); /* jdonald alignment? */ 		\
	if (_fault != md_fault_none)                               \
		DECLARE_FAULT(_fault);                                  \
	WRITE_WORD((PPC_FPR_W(FS)), _ea+4, _fault);		\
	if (_fault != md_fault_none)                               \
		DECLARE_FAULT(_fault);                                  \
}
    
  
DEFINST(STFDX,                  0x5AE,
        "stfdx",                "S,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        DNA,DNA,                PPC_DFPR(FS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)


#define STFDUX_IMPL                                                     \
   {                                                                    \
        enum md_fault_type _fault;                                      \
        if(RA==0){                                                      \
                DECLARE_FAULT(md_fault_invalidinstruction);             \
                }                                                       \
        else{                                                           \
                WRITE_WORD( (PPC_FPR_UW(FS)), GPR(RA)+GPR(RB), _fault);	\
			 	DEFTRACE(GPR(RA) + GPR(RB), "memory"); /* jdonald alignment? */ 		\
                if (_fault != md_fault_none)                            \
                        DECLARE_FAULT(_fault);                          \
                WRITE_WORD( (PPC_FPR_W(FS)), GPR(RA)+GPR(RB)+4, _fault);\
                if (_fault != md_fault_none)                            \
                        DECLARE_FAULT(_fault);                          \
                SET_GPR(RA, GPR(RA)+GPR(RB));                           \
        }                                                               \
   }
        
DEFINST(STFDUX,                 0x5EE,
        "stfdux",               "S,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        PPC_DGPR(RA),DNA,       PPC_DFPR_DW(FS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)


#define LHBRX_IMPL							\
   {									\
     byte_t _src1, _src2;						\
     enum md_fault_type _fault;                                         \
     sword_t _ea;							\
     if(RA!=0){                                                         \
		_ea=GPR(RA)+GPR(RB);					\
        }                                                               \
     else{                                                              \
		_ea=0+GPR(RB);						\
	}								\
	_src1 = READ_BYTE(_ea, _fault);                     		\
     DEFTRACE(_ea, "memory"); /* jdonald alignment? */ \
     if (_fault != md_fault_none)                                       \
           DECLARE_FAULT(_fault);                                       \
	_src2 = READ_BYTE(_ea+1, _fault);                   		\
     if (_fault != md_fault_none)                                       \
           DECLARE_FAULT(_fault);                                       \
	SET_GPR(RD,( ((word_t)_src1) || (((word_t)_src2) << 8) ) );	\
   }

DEFINST(LHBRX,                  0x62C,
        "lhbrx",                "d,a,b",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RD),DNA,       DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)

/*FixMe: The functional units used here need to be checked.*/
	
#define EIEIO_IMPL						\
   {								\
	EXEC_EIEIO;						\
   }

DEFINST(EIEIO,			0x6AC,
	"eieio",		"",
	FUClass_NA,		F_MEM,
	DNA,DNA,		DNA,DNA,DNA,
        DNA, DNA, DNA,         	DNA, DNA)


  
#define STHBRX_IMPL							\
   {									\
    half_t _src;							\
    enum md_fault_type _fault;						\
    byte_t _src1, _src2;						\
    _src1 =(byte_t)( (word_t)(GPR(RS)) & 0xff );			\
    _src2 =(byte_t)( ((word_t)(GPR(RS)) & 0xff00)>>8 );			\
    _src = (((half_t)_src1)<<8) || ((half_t)_src2); 			\
    if(RA==0){								\
		WRITE_HALF( _src, GPR(RB), _fault);			\
	    DEFTRACE(GPR(RB), "memory"); 		\
	}								\
    else{								\
		WRITE_HALF( _src, GPR(RA)+GPR(RB), _fault);             \
		DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
    }									\
    if (_fault != md_fault_none)                            		\
	    DECLARE_FAULT(_fault);                          		\
   }

DEFINST(STHBRX,                 0x72C,
        "sthbrx",               "s,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        DNA,DNA,                PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)

#define ICBI_IMPL                                               \
   {                                                            \
	if(RA==0){						\
		EXEC_ICBI(GPR(RB));                     	\
	}							\
        else{							\
		EXEC_ICBI(GPR(RA)+GPR(RB));                     \
	} 							\
  }    

DEFINST(ICBI,                   0x7AC,
        "icbi",                 "a,b",
        IntALU,             	F_RR,
        DNA,DNA,                PPC_DGPR(RA),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,          DNA, DNA)



#define DCBZ_IMPL                                               \
   {                                                            \
	if(RA==0){						\
	    EXEC_DCBZ(GPR(RB));                     	\
		DEFTRACE(GPR(RB), "DCBx"); 		\
	}							\
	else{	        					\
		EXEC_DCBZ(GPR(RA)+GPR(RB));                     \
		DEFTRACE(GPR(RA) + GPR(RB), "DCBx"); 		\
	}							\
   }    	
    
DEFINST(DCBZ,                   0x3EC,
        "dcbz",                 "a,b",
        IntALU,             	F_RR,
        DNA,DNA,                PPC_DGPR(RA),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,          DNA, DNA)



#define STFIWX_IMPL						\
   {								\
        enum md_fault_type _fault;				\
        if(RA==0){						\
                 WRITE_WORD((PPC_FPR_UW(FS)), GPR(RB), _fault);	\
			 DEFTRACE(GPR(RB), "memory"); 		\
                }						\
        else{							\
             WRITE_WORD((PPC_FPR_UW(FS)),GPR(RA)+GPR(RB),_fault);	\
			 DEFTRACE(GPR(RA) + GPR(RB), "memory"); 		\
        }							\
        if (_fault != md_fault_none)				\
                DECLARE_FAULT(_fault);				\
   }
        
DEFINST(STFIWX,                 0x7AE,
        "stfiwx",               "S,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        DNA,DNA,                PPC_DFPR(FS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)
                

#define ADDC_IMPL				\
  {						\
	sword_t _ra,_rb;			\
	_ra = GPR(RA);				\
	_rb = GPR(RB);				\
        SET_GPR(RD, _ra + _rb);			\
	if(carrygenerated(_ra, _rb)){		\
		PPC_SET_XER_CA;			\
	}					\
	else { PPC_RESET_XER_CA;}		\
  }


DEFINST(ADDC,                   0x14,
        "addc",                 "d,a,b",    
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB), DNA,
        DNA,DNA,DNA,            DNA,DNA)


#define ADDCD_IMPL					\
  {							\
    sword_t  _src;					\
    sword_t _ra,_rb;                                   \
    _ra = GPR(RA);                                      \
    _rb = GPR(RB);                                      \
							\
    _src = _ra + _rb;					\
        if(!(_src)) PPC_SET_CR0_EQ;		      	\
        else PPC_RESET_CR0_EQ;				\
        if(_src>0) PPC_SET_CR0_GT;		      	\
        else PPC_RESET_CR0_GT;				\
        if(_src<0) PPC_SET_CR0_LT;		       	\
        else PPC_RESET_CR0_LT;				\
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;	       	\
        else PPC_RESET_CR0_SO;				\
        SET_GPR(RD, _src);				\
	if(carrygenerated(_ra, _rb)){			\
	PPC_SET_XER_CA;					\
	}						\
	else{ PPC_RESET_XER_CA;}		      	\
}


DEFINST(ADDCD,                  0x15,
       "addc.",                "d,a,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), PPC_DCR,  PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER, 
        PPC_DXER,DNA,DNA,       DNA,DNA)


#define ADDCO_IMPL                                      \
  {                                                     \
	sword_t _ra,_rb;                        	\
        _ra = GPR(RA);                 			\
        _rb = GPR(RB);                          	\
         if (OVER(_ra, _rb)){                   	\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
        SET_GPR(RD, (_ra + _rb));                 	\
	if(carrygenerated(_ra, _rb)){			\
	PPC_SET_XER_CA;					\
	}						\
	else{ PPC_RESET_XER_CA;}	      		\
  }     

DEFINST(ADDCO,                  	0x414,
        "addco",                	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        DNA,DNA,DNA,            	DNA,DNA)




#define ADDCOD_IMPL                                     \
  {                                                     \
        sword_t  _src;                                  \
        sword_t _ra,_rb;                                \
        _ra = GPR(RA);                                  \
        _rb = GPR(RB);                                  \
         if (OVER(_ra, _rb)){                           \
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = _ra + _rb;                              \
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
	if(carrygenerated(_ra, _rb)){		        \
	PPC_SET_XER_CA;					\
	}						\
	else{ PPC_RESET_XER_CA;}			\
  }
 
DEFINST(ADDCOD,                 	0x415,
        "addco.",               	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        PPC_DCR,DNA,DNA,            	PPC_DCR,DNA)
        


#define MULHWU_IMPL                                                     \
  {                                                                     \
        qword_t _res;							\
        _res = (qword_t) GPR(RA) * (qword_t)GPR(RB);			\
        _res = (_res >> 32);                                            \
        SET_GPR(RD, (word_t)(_res));                                    \
  }

DEFINST(MULHWU,                 0x16,
        "mulhwu",               "d,a,b", 
        IntMULT,                F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB), DNA,
	DNA, DNA, DNA,		DNA,DNA)


#define MULHWUD_IMPL					\
  {							\
        qword_t _src;					\
        _src = (qword_t) GPR(RA) * (qword_t)GPR(RB);	\
        _src = (_src >> 32);				\
        SET_GPR(RD, (word_t)(_src));			\
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
  }
   
DEFINST(MULHWUD,                0x17,
        "mulhwu.",              "d,a,b",
        IntMULT,                F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB), DNA,
        DNA, DNA, DNA,          DNA,DNA)




#define SLW_IMPL							\
   {									\
	word_t  _s, _b, _n;						\
	_b = GPR(RB);							\
	_n = _b&0x1F;							\
	_s = GPR(RS);							\
	if(!(_b&0x20)){ 						\
		SET_GPR(RA, (_s<<_n));					\
	}								\
	else{								\
		SET_GPR(RA,0);						\
	}								\
   }

DEFINST(SLW,			0x30,
	"slw",			"a,s,b",
	IntALU,			F_ICOMP,
	PPC_DGPR(RA),DNA,	PPC_DGPR(RB),PPC_DGPR(RS),DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define SLWD_IMPL                                                       \
   {                                                                    \
        word_t  _s, _b, _n, _src;                                       \
        _b = GPR(RB);                                                   \
        _n = _b&0x1F;                                                   \
        _s = GPR(RS);                                                   \
        if(!(_b&0x20)){                                                 \
		_src = (_s<<_n);				        \
                SET_GPR(RA, _src);                                  	\
		if(!(_src)) PPC_SET_CR0_EQ;                                 \
        	else PPC_RESET_CR0_EQ;                                  \
        	if(_src>0) PPC_SET_CR0_GT;                                  \
        	else PPC_RESET_CR0_GT;                                  \
        	if(_src<0) PPC_SET_CR0_LT;                                  \
        	else PPC_RESET_CR0_LT;                                  \
        	if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                          \
        	else PPC_RESET_CR0_SO;                                  \
        }                                                               \
        else{                                                           \
                SET_GPR(RA,0);                                          \
		PPC_SET_CR0_EQ; 					\
                PPC_RESET_CR0_GT;                                      	\
                PPC_RESET_CR0_LT;                                      	\
                if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                      \
                else PPC_RESET_CR0_SO;                                  \
        }                                                               \
   }

DEFINST(SLWD,                   0x31,
        "slw.",                 "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,  	PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,        	DNA, DNA)



#define SRW_IMPL                                                        \
   {                                                                    \
        word_t  _s, _b, _n;						\
        _b = GPR(RB);                                                   \
        _n = _b&0x1F;                                                   \
        _s =((word_t) GPR(RS) )>>_n;					\
        SET_GPR(RA, _s);	                                	\
   }

DEFINST(SRW,                    0x430,
        "srw",                  "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA), DNA,     	PPC_DGPR(RB),PPC_DGPR(RS),DNA,
        DNA, DNA, DNA,        	DNA, DNA)



#define SRWD_IMPL                                                       \
   {                                                                    \
        word_t  _s, _b, _n, _src;                                       \
        _b = GPR(RB);                                                   \
        _n = _b&0x1F;                                                   \
        _s = GPR(RS);                                                   \
         _src = (_s>>_n);                                        	\
         SET_GPR(RA, _src);                                     	\
         if(!(_src)) PPC_SET_CR0_EQ;                                 	\
         else PPC_RESET_CR0_EQ;                                      	\
         if(_src>0) PPC_SET_CR0_GT;                                  	\
         else PPC_RESET_CR0_GT;                                      	\
         if(_src<0) PPC_SET_CR0_LT;                                  	\
         else PPC_RESET_CR0_LT;                                      	\
         if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                            	\
         else PPC_RESET_CR0_SO;                                      	\
    }

DEFINST(SRWD,                   0x431,
        "srw.",                 "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,          DNA, DNA)




#define SRAW_IMPL                                                       \
   {                                                                    \
        sword_t  _s, _b, _n, _src,_m;					\
        int _i;                                                         \
        _b = GPR(RB);                                                   \
        _n = _b&0x1F;           		                        \
	_s = GPR(RS);							\
	if(_b&0x20){							\
		if(_s<0){						\
		 _src = 0xffffffff;					\
		if(_s&0x7fffffff) PPC_SET_XER_CA;			\
		else PPC_RESET_XER_CA;					\
		}							\
		else{							\
		 _src=0x0;						\
		 PPC_RESET_XER_CA;					\
		}							\
	}								\
	else{								\
		_src=_s>>_n;						\
	 	if(_s<0){                                              	\
			for(_i=0;_i<_n;_i++){				\
				_m= _m<<1;				\
				_m=_m|0x1;				\
			}						\
                        if(_s&_m) PPC_SET_XER_CA;                   	\
                        else PPC_RESET_XER_CA;                          \
                }                                                       \
		else PPC_RESET_XER_CA;					\
        }                                                               \
        SET_GPR(RA, _src);                                              \
   }
                
DEFINST(SRAW,                   	0x630,
        "sraw",                 	"a,s,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RA), PPC_DXER,         PPC_DGPR(RB),PPC_DGPR(RS),PPC_DXER,
        DNA, DNA, DNA,          	DNA, DNA)


#define SRAWD_IMPL                                                      \
   {                                                                    \
        sword_t  _s, _b, _n, _src,_m;                                   \
        int _i;                                                         \
        _b = GPR(RB);                                                   \
        _n = _b&0x1F;                                                   \
        _s = GPR(RS);                                                   \
        if(_b&0x20){                                                    \
                if(_s<0){                                               \
                         _src = 0xffffffff;                             \
                        if(_s&0x7fffffff) PPC_SET_XER_CA;               \
                        else PPC_RESET_XER_CA;                          \
                }                                                       \
                else{                                                   \
                 _src=0x0;                                              \
                 PPC_RESET_XER_CA;                                      \
                }                                                       \
        }                                                               \
        else{                                                           \
                _src=_s>>_n;                                            \
                if(_s<0){                                               \
                        for(_i=0;_i<_n;_i++){                           \
                                _m= _m<<1;                              \
                                _m=_m|0x1;                              \
                        }                                               \
                        if(_s&_m) PPC_SET_XER_CA;                       \
                        else PPC_RESET_XER_CA;                          \
                }                                                       \
                else PPC_RESET_XER_CA;                                  \
        }                                                               \
        SET_GPR(RA, _src);                                              \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }

DEFINST(SRAWD,                  	0x631,
        "sraw.",                	"a,s,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RA), PPC_DXER,         PPC_DGPR(RB),PPC_DGPR(RS),PPC_DXER,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)
        
 

#define SRAWI_IMPL                                                      \
   {                                                                    \
        sword_t  _s, _b, _n, _src,_m;                                   \
        int _i;                                                         \
        _b = SH;                        	                        \
        _n = _b&0x1F;                                                   \
        _s = GPR(RS);                                                   \
        if(_b&0x20){                                                    \
                if(_s<0){                                               \
                         _src = 0xffffffff;                             \
                        if(_s&0x7fffffff) PPC_SET_XER_CA;               \
                        else PPC_RESET_XER_CA;                          \
                }                                                       \
                else{                                                   \
                 _src=0x0;                                              \
                 PPC_RESET_XER_CA;                                      \
                }                                                       \
        }                                                               \
        else{                                                           \
                _src=_s>>_n;                                            \
                if(_s<0){                                               \
                        for(_i=0;_i<_n;_i++){                           \
                                _m= _m<<1;                              \
                                _m=_m|0x1;                              \
                        }                                               \
                        if(_s&_m) PPC_SET_XER_CA;                       \
                        else PPC_RESET_XER_CA;                          \
                }                                                       \
                else PPC_RESET_XER_CA;                                  \
        }                                                               \
        SET_GPR(RA, _src);                                              \
   }
    
DEFINST(SRAWI,                  0x670,
        "srawi",                "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA), PPC_DXER, PPC_DGPR(RB),PPC_DGPR(RS),PPC_DXER,
        DNA, DNA, DNA,          DNA, DNA)






#define SRAWID_IMPL                                                     \
   {                                                                    \
        sword_t  _s, _b, _n, _src,_m;                                   \
        int _i;                                                         \
        _b = SH;                                                   	\
        _n = _b&0x1F;                                                   \
        _s = GPR(RS);                                                   \
        if(_b&0x20){                                                    \
                if(_s<0){                                               \
                         _src = 0xffffffff;                             \
                        if(_s&0x7fffffff) PPC_SET_XER_CA;               \
                        else PPC_RESET_XER_CA;                          \
                }                                                       \
                else{                                                   \
                 _src=0x0;                                              \
                 PPC_RESET_XER_CA;                                      \
                }                                                       \
        }                                                               \
        else{                                                           \
                _src=_s>>_n;                                            \
                if(_s<0){                                               \
                        for(_i=0;_i<_n;_i++){                           \
                                _m= _m<<1;                              \
                                _m=_m|0x1;                              \
                        }                                               \
                        if(_s&_m) PPC_SET_XER_CA;                       \
                        else PPC_RESET_XER_CA;                          \
                }                                                       \
                else PPC_RESET_XER_CA;                                  \
        }                                                               \
        SET_GPR(RA, _src);                                              \
        if(!(_src)) PPC_SET_CR0_EQ;                                         \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                          \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                          \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                                  \
        else PPC_RESET_CR0_SO;                                          \
   }
                        
DEFINST(SRAWID,                 	0x671,
        "srawi.",               	"a,s,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RA), PPC_DXER,         PPC_DGPR(RB),PPC_DGPR(RS),PPC_DXER,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)





#define CNTLZW_IMPL							\
   {									\
	int _n=0;							\
	word_t _src, _mask;						\
	_mask = 0x80000000;						\
	_src = GPR(RS);							\
	while(_n<32)							\
	{								\
		if(_mask&_src) break;					\
		else{							\
			_n++;						\
			_mask = _mask >>1;				\
		}							\
	}								\
	SET_GPR(RA, _n);						\
   }

DEFINST(CNTLZW,			0x34,
	"cntlzw",		"a,s",
	IntALU,			F_ICOMP,
	PPC_DGPR(RA),DNA,	PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)





#define CNTLZWD_IMPL                                                    \
   {                                                                    \
        int _n=0;                                                       \
        word_t _src, _mask;                                             \
        _mask = 0x80000000;                                             \
        _src = GPR(RS);                                                 \
        while(_n<32)                                                    \
        {                                                               \
                if(_mask&_src) break;                                   \
                else{                                                   \
                        _n++;                                           \
                        _mask = _mask >>1;                              \
                }                                                       \
        }                                                               \
        SET_GPR(RA, _n);                                                \
        if(!(_n)) PPC_SET_CR0_EQ;                                     	\
        else PPC_RESET_CR0_EQ;                                          \
        if(_n>0) PPC_SET_CR0_GT;                                      	\
        else PPC_RESET_CR0_GT;                                          \
        if(_n<0) PPC_SET_CR0_LT;                                        \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }

DEFINST(CNTLZWD,                0x35,
        "cntlzw.",              "a,s",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)

  


#define AND_IMPL							\
   {									\
	SET_GPR(RA, GPR(RS)& GPR(RB));					\
   }

DEFINST(AND,			0x38,
	"and",			"a,s,b",
	IntALU,			F_ICOMP,
	PPC_DGPR(RA),DNA,	PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)
		


#define ANDD_IMPL                                                       \
   {                                                                    \
	sword_t	_src;							\
	_src = GPR(RS)& GPR(RB);					\
        SET_GPR(RA, _src);                                  		\
	if(!(_src)) PPC_SET_CR0_EQ;				        \
	else PPC_RESET_CR0_EQ;						\
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
	if(PPC_GET_XER_SO) PPC_SET_CR0_SO;				\
	else PPC_RESET_CR0_SO;						\
   }

DEFINST(ANDD,                   0x39,
        "and.",                 "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,	PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,        	DNA, DNA)





#define ANDC_IMPL                                                       \
   {                                                                    \
        SET_GPR(RA, GPR(RS)& (~(GPR(RB))));                             \
   }
        
DEFINST(ANDC,                   0x78,
        "andc",                 "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),DNA,           PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)

   

#define ANDCD_IMPL                                                      \
   {                                                                    \
        sword_t _src;                                                   \
        _src = GPR(RS)& (~(GPR(RB)));					\
        SET_GPR(RA, _src);                                              \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }

DEFINST(ANDCD,                  0x79,
        "andc.",                "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,        	DNA, DNA)



#define MULHW_IMPL							\
  {                                                                     \
	sqword_t _res;							\
	_res = (sqword_t) GPR(RA) * (sqword_t)GPR(RB); 			\
	_res = (_res >> 32);						\
	SET_GPR(RD, (sword_t)(_res));					\
  }
   
DEFINST(MULHW,                  0x96,
        "mulhw",                "d,a,b", 
        IntMULT,                F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB), DNA,
	DNA, DNA, DNA,		DNA, DNA)
 
#define MULHWD_IMPL					\
  {							\
        sqword_t _src;					\
        _src = (sqword_t) GPR(RA) * (sqword_t)GPR(RB);	\
        _src = (_src >> 32);				\
        SET_GPR(RD, (sword_t)(_src));			\
        if(!(_src)) PPC_SET_CR0_EQ;			\
        else PPC_RESET_CR0_EQ;				\
        if(_src>0) PPC_SET_CR0_GT;			\
        else PPC_RESET_CR0_GT;				\
        if(_src<0) PPC_SET_CR0_LT;			\
        else PPC_RESET_CR0_LT;				\
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;	        \
        else PPC_RESET_CR0_SO;				\
  }

DEFINST(MULHWD,                 	0x97,
        "mulhw.",               	"d,a,b",
        IntMULT,                	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)


#define NOR_IMPL                                                        \
   {                                                                    \
        SET_GPR(RA, ~(GPR(RS) | GPR(RB)));                              \
   }

DEFINST(NOR,                    0xF8,
        "nor",                  "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define NORD_IMPL                                                       \
   {                                                                    \
        sword_t _src;                                                   \
        _src = ~(GPR(RS)| GPR(RB));                                     \
        SET_GPR(RA, _src);                                              \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }

DEFINST(NORD,                  0xF9,
        "nor.",                "a,s,b",
        IntALU,                F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,  PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,         DNA, DNA)




#define SUBF_IMPL                                                       \
  {                                                                     \
        SET_GPR(RD, GPR(RB) - GPR(RA));                                 \
  }

DEFINST(SUBF,                   0x50,
        "subf",                 "d,a,b", 
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,          DNA, DNA)


#define SUBFO_IMPL					\
  {							\
	if (UNDER(GPR(RB), GPR(RA))){                   \
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
        SET_GPR(RD, GPR(RB) - GPR(RA));			\
  }
        
DEFINST(SUBFO,                  	0x450,
        "subfo",                	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
	DNA,DNA,DNA,			DNA,DNA)
        



#define SUBFOD_IMPL                                     \
  {                                                     \
        sword_t  _src;                                  \
         if (UNDER(GPR(RB), GPR(RA))){                  \
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = GPR(RB) - GPR(RA);                      \
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                         \
        else PPC_RESET_CR0_EQ;                              \
        if(_src>0) PPC_SET_CR0_GT;                          \
        else PPC_RESET_CR0_GT;                              \
        if(_src<0) PPC_SET_CR0_LT;                          \
        else PPC_RESET_CR0_LT;                              \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                  \
        else PPC_RESET_CR0_SO;                              \
  }
        
DEFINST(SUBFOD,                 	0x451,
        "subfo.",               	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        PPC_DCR,DNA,DNA,            	PPC_DCR,DNA)


#define SUBFD_IMPL                                                      \
  {                                                                     \
    sword_t  _src;                                                      \
                                                                        \
    _src = GPR(RB) - GPR(RA);                                           \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
        SET_GPR(RD, _src);                                              \
   }

DEFINST(SUBFD,                  	0x51,
        "subf.",                	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
	DNA, DNA, DNA,			DNA,DNA)


#define NEG_IMPL                                                       	\
  {                                                                     \
    SET_GPR(RD, -GPR(RA));                                		\
  }
 
DEFINST(NEG,                    0xD0,
        "neg",                  "d,a",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), DNA, DNA,
	DNA, DNA, DNA,		DNA,DNA)


#define NEGD_IMPL							\
  { 									\
    sword_t _src;                                                       \
    _src = -GPR(RA);							\
    SET_GPR(RD, _src);                                              	\
        if(!(_src)) PPC_SET_CR0_EQ;					\
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
        SET_GPR(RD, _src);                                              \
  }


DEFINST(NEGD,                   	0xD1,
        "neg.",                	 	"d,a",
        IntALU,                	 	F_ICOMP,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), DNA, DNA,
	DNA,DNA,DNA,			DNA,DNA)



#define NEGO_IMPL			\
  {					\
    SET_GPR(RD, -GPR(RA));		\
    if(((word_t)GPR(RA))==0x80000000){	\
	PPC_SET_XER_OV;PPC_SET_XER_SO;	\
    }					\
    else{PPC_RESET_XER_OV;}		\
  }
        
DEFINST(NEGO,                   0x4D0,
        "nego",                 "d,a",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), DNA, DNA,
        DNA, DNA, DNA,          DNA,DNA)
 

#define NEGOD_IMPL			\
  {					\
    sword_t _src;			\
    _src = -GPR(RA);			\
    SET_GPR(RD, _src);			\
        if(!(_src)) PPC_SET_CR0_EQ;	\
        else PPC_RESET_CR0_EQ;		\
        if(_src>0) PPC_SET_CR0_GT;	\
        else PPC_RESET_CR0_GT;		\
        if(_src<0) PPC_SET_CR0_LT;	\
        else PPC_RESET_CR0_LT;		\
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;	\
        else PPC_RESET_CR0_SO;		\
        SET_GPR(RD, _src);		\
    if(((word_t)GPR(RA))==0x80000000){	\
	PPC_SET_XER_OV;PPC_SET_XER_SO;	\
    }					\
    else{PPC_RESET_XER_OV;}		\
  }

DEFINST(NEGOD,                  	0x4D1,   
        "nego.",                	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), DNA, DNA,
        DNA,DNA,DNA,            	DNA,DNA)



#define SUBFE_IMPL                              \
  {                               	        \
	sword_t _ra,_rb,_ca;                    \
        _ra = ~((sword_t)GPR(RA));              \
        _rb = GPR(RB);                          \
        _ca = PPC_GET_XER_CA;                   \
        SET_GPR(RD, _ra + _rb+_ca);		\
        if(carrygenerated(_rb, _ra)){		\
                PPC_SET_XER_CA;                 \
        }                                       \
        else if(carrygenerated(_rb+_ra,_ca)){	\
                PPC_SET_XER_CA;                 \
        }                                       \
        else { PPC_RESET_XER_CA;}               \
  }

DEFINST(SUBFE,                  0x110,
        "subfe",                "d,a,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB), DNA, 
        DNA,DNA,DNA,            DNA,DNA)





#define SUBFED_IMPL                                     \
  {                                                     \
    sword_t  _src;                                      \
  sword_t _ra,_rb,_ca;                                	\
    _ra = ~((sword_t)GPR(RA));                          \
    _rb = GPR(RB);                                      \
    _ca = PPC_GET_XER_CA;                               \
                                                        \
    _src = _ra + _rb+_ca;    				\
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        SET_GPR(RD, _src);                              \
        if(carrygenerated(_rb, _ra)){           	\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else if(carrygenerated( (_rb+ _ra),_ca ) ){	\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }
 

DEFINST(SUBFED,                 0x111,
        "subfe.",               "d,a,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), PPC_DCR,  PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
        PPC_DXER,DNA,DNA,       PPC_DXER,DNA)
        

#define SUBFEO_IMPL                                     \
  {                                                     \
	sword_t _ra,_rb,_ca;                        	\
        _ra = ~((sword_t)GPR(RA));                 	\
        _rb = GPR(RB);     			       	\
	_ca = PPC_GET_XER_CA;				\
         if (OVER(_rb, _ra )){   			\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
         else if (OVER(_rb+ _ra, _ca)){  		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
        SET_GPR(RD, _rb + _ra+_ca);      		\
        if(carrygenerated(_rb, _ra)){                   \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else if(carrygenerated(_rb+ _ra, _ca)){         \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }

DEFINST(SUBFEO,                 	0x510,
        "subfeo",               	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        DNA,DNA,DNA,            	DNA,DNA)




#define SUBFEOD_IMPL                                    \
  {                                                     \
        sword_t  _src;                                  \
        sword_t _ra,_rb,_ca;                            \
        _ra = ~((sword_t)GPR(RA));                      \
        _rb = GPR(RB);                                  \
        _ca = PPC_GET_XER_CA;                           \
        if (OVER( _rb, _ra)){				\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else if (OVER(_rb+ _ra,_ca)){    		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = _rb + _ra+_ca;				\
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
             else PPC_RESET_CR0_EQ;                     \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        if(carrygenerated(_rb, _ra ) ){                 \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else if(carrygenerated(_rb+_ra,_ca)){           \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }


DEFINST(SUBFEOD,                	0x511,
        "subfeo.",              	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        PPC_DCR,DNA,DNA,            	PPC_DCR,DNA)





#define ADDE_IMPL                               \
{                                             	\
  	sword_t _ra,_rb,_ca;			\
	_ra = GPR(RA);				\
	_rb = GPR(RB);				\
	_ca = PPC_GET_XER_CA;			\
        SET_GPR(RD, _ra + _rb+ _ca);         	\
        if(carrygenerated(_ra, _rb)){           \
                PPC_SET_XER_CA;                 \
        }                                       \
        else if((_ca!=0)&&carrygenerated(_ra + _rb, _ca)){ \
                PPC_SET_XER_CA;                 \
        }                                       \
	else { PPC_RESET_XER_CA;}               \
  }

DEFINST(ADDE,                   	0x114,
        "adde",                 	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,  
        DNA,DNA,DNA,            	DNA,DNA)
        

#define ADDED_IMPL                                      \
  {                                                     \
    sword_t  _src;                                      \
    sword_t _ra,_rb,_ca;                                \
    _ra = GPR(RA);                                      \
    _rb = GPR(RB);                                      \
    _ca = PPC_GET_XER_CA;                               \
    _src = _ra + _rb+ _ca;                	        \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        SET_GPR(RD, _src);                              \
        if(carrygenerated(_ra, _rb)){           	\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else if((_ca!=0)&&carrygenerated( _ra+ _rb,_ca ) ){	\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
}       
        
DEFINST(ADDED,                  0x115,
        "adde.",                "d,a,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), PPC_DCR,  PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR, 
        PPC_DXER,DNA,DNA,       PPC_DXER,DNA)




#define ADDEO_IMPL                	                \
  {                                                     \
	sword_t _ra,_rb,_ca;                        	\
	_ca = PPC_GET_XER_CA;				\
        _ra = GPR(RA);                 			\
        _rb = GPR(RB);                          	\
         if (OVER(_ra, _rb)){                   	\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
         else if (OVER(_ra+ _rb, _ca)){  	        \
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
        SET_GPR(RD, _ra+_rb+_ca);                       \
        if(carrygenerated(_ra, _rb)){                   \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else if((_ca!=0)&&carrygenerated(_ra+_rb, _ca)){\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }
  
DEFINST(ADDEO,                  	0x514,
        "addeo",               	 	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        DNA,DNA,DNA,            	DNA,DNA)


#define ADDEOD_IMPL                                     \
  {                                                     \
        sword_t  _src;                                  \
	sword_t _ra,_rb,_ca;                            \
        _ra = GPR(RA);                                  \
        _rb = GPR(RB);                                  \
	_ca = PPC_GET_XER_CA;				\
        if (OVER(_ra, _rb)){                   		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else if ((_ca!=0)&&OVER(_ra+ _rb,_ca)){		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = _ra+_rb+_ca;           			\
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        if(carrygenerated(_ra, _rb)){                   \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else if(carrygenerated(_ra+_rb,_ca)){           \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }

DEFINST(ADDEOD,                	 	0x515,
        "addeo.",              		"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        PPC_DCR,DNA,DNA,            	PPC_DCR,DNA)




#define SUBFZE_IMPL                                 \
  {                                                 \
    SET_GPR(RD, (~((sword_t)GPR(RA))) + PPC_GET_XER_CA  );      \
    if( carrygenerated(~((sword_t)GPR(RA)) , PPC_GET_XER_CA) ){ \
        PPC_SET_XER_CA;                             \
    }                                               \
    else{ PPC_RESET_XER_CA;}                        \
  }

DEFINST(SUBFZE,                 	0x190,
        "subfze",               	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)


#define SUBFZED_IMPL                            \
  {                                             \
    sword_t _src;                               \
    _src= (~((sword_t)GPR(RA))) + PPC_GET_XER_CA;\
    if( carrygenerated((~((sword_t)GPR(RA))), PPC_GET_XER_CA) ){\
        PPC_SET_XER_CA;                             \
    }                                               \
    else{ PPC_RESET_XER_CA;}                        \
        if(!(_src)) PPC_SET_CR0_EQ;                 \
        else PPC_RESET_CR0_EQ;                      \
        if(_src>0) PPC_SET_CR0_GT;                  \
        else PPC_RESET_CR0_GT;                      \
        if(_src<0) PPC_SET_CR0_LT;                  \
        else PPC_RESET_CR0_LT;                      \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;          \
        else PPC_RESET_CR0_SO;                      \
        SET_GPR(RD, _src);                          \
  }

DEFINST(SUBFZED,                	0x191,
        "subfze.",              	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA)





#define SUBFZEO_IMPL                                    \
  {                                                     \
 	sword_t _ra,_ca;                        	\
        _ra = ~((sword_t)GPR(RA));                 	\
        _ca = PPC_GET_XER_CA;                          	\
         if (OVER(_ra, _ca)){            		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
        SET_GPR(RD, _ra +_ca);      			\
        if(carrygenerated(_ra, _ca)){        		\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }

DEFINST(SUBFZEO,               	 	0x590,
        "subfzeo",              	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)




#define SUBFZEOD_IMPL                                   \
  {                                                     \
        sword_t  _src;                                  \
	sword_t _ra,_ca;				\
	_ca = PPC_GET_XER_CA;				\
	_ra = ~((sword_t)GPR(RA));			\
        if (OVER(_ra,_ca)){                		\
               PPC_SET_XER_SO; PPC_SET_XER_OV;          \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = _ra +_ca;                  	        \
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        if(carrygenerated(_ra,_ca)){                    \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }
   
   
   

DEFINST(SUBFZEOD,               	0x591,
        "subfzeo.",             	"d,a",
        IntALU,                 	F_ICOMP, 
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA)




#define ADDZE_IMPL                                  \
  {                                                 \
    SET_GPR(RD, GPR(RA) + PPC_GET_XER_CA  );        \
    if( carrygenerated(GPR(RA), PPC_GET_XER_CA) ){  \
        PPC_SET_XER_CA;                             \
    }                                               \
    else{ PPC_RESET_XER_CA;}                        \
  }

DEFINST(ADDZE,                  	0x194,
        "addze",                	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)


#define ADDZED_IMPL                             \
  {                                             \
    sword_t _src;                               \
    _src= GPR(RA) + PPC_GET_XER_CA;                 \
    if( carrygenerated(GPR(RA), PPC_GET_XER_CA) ){  \
        PPC_SET_XER_CA;                             \
    }                                               \
    else{ PPC_RESET_XER_CA;}                        \
        if(!(_src)) PPC_SET_CR0_EQ;                 \
        else PPC_RESET_CR0_EQ;                      \
        if(_src>0) PPC_SET_CR0_GT;                  \
        else PPC_RESET_CR0_GT;                      \
        if(_src<0) PPC_SET_CR0_LT;                  \
        else PPC_RESET_CR0_LT;                      \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;          \
        else PPC_RESET_CR0_SO;                      \
        SET_GPR(RD, _src);                          \
  }
        
DEFINST(ADDZED,                 	0x195,
        "addze.",               	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA)
    
   
#define ADDZEO_IMPL                                     \
  {                                                     \
 	sword_t _ra,_ca;                        	\
        _ra = GPR(RA);                 			\
        _ca = PPC_GET_XER_CA;                          	\
         if (OVER(_ra, _ca)){            		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;} 		        \
        SET_GPR(RD, _ra + _ca);      			\
        if(carrygenerated(_ra, _ca)){        		\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }

DEFINST(ADDZEO,                 	0x594,
        "addzeo",               	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)
 


#define ADDZEOD_IMPL                                    \
  {                                                     \
        sword_t  _src;                                  \
	sword_t _ra,_ca;				\
	_ra = GPR(RA);					\
	_ca = PPC_GET_XER_CA;				\
        if (OVER(_ra,_ca)){                		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = _ra + _ca;                       	\
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        if(carrygenerated(_ra,_ca)){                    \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }

        
    
                
DEFINST(ADDZEOD,                	0x595,
        "addzeo.",              	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA)



#define SUBFME_IMPL                             \
  {                                             \
	sword_t _ra,_ca;			\
	_ra = ~((sword_t)GPR(RA));		\
	_ca = PPC_GET_XER_CA;			\
    SET_GPR(RD, _ra + _ca - 1 );                \
    if( carrygenerated(_ra, (_ca-1)) ){         \
        PPC_SET_XER_CA;                         \
    }                                           \
    else{ PPC_RESET_XER_CA;}                    \
  }

DEFINST(SUBFME,                 	0x1D0,
        "subfme",               	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)

#define SUBFMED_IMPL                            \
  {                                             \
    sword_t _src;                               \
    sword_t _ra,_ca;                            \
        _ra = ~((sword_t)GPR(RA));              \
        _ca =PPC_GET_XER_CA;                    \
    _src= _ra + _ca -1;     			\
    if( carrygenerated(_ra, (_ca-1)) ){		\
        PPC_SET_XER_CA;                         \
    }                                           \
    else{ PPC_RESET_XER_CA;}                    \
        if(!(_src)) PPC_SET_CR0_EQ;             \
        else PPC_RESET_CR0_EQ;                  \
        if(_src>0) PPC_SET_CR0_GT;              \
        else PPC_RESET_CR0_GT;                  \
        if(_src<0) PPC_SET_CR0_LT;              \
        else PPC_RESET_CR0_LT;                  \
       if(PPC_GET_XER_SO) PPC_SET_CR0_SO;       \
        else PPC_RESET_CR0_SO;                  \
        SET_GPR(RD, _src);                      \
  }
    
DEFINST(SUBFMED,                	0x1D1,
        "subfme.",              	"d,a,i",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA) 



#define SUBFMEO_IMPL                                    \
  {                                                     \
 	sword_t _ra,_ca;                        	\
        _ra = ~((sword_t)GPR(RA));                 	\
        _ca = PPC_GET_XER_CA;                          	\
        if (OVER(_ra, (_ca-1))){            		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
        SET_GPR(RD, _ra +_ca-1);      			\
        if(carrygenerated(_ra, (_ca-1))){           	\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }

DEFINST(SUBFMEO,                	0x5D0,   
        "subfmeo",              	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)

#define SUBFMEOD_IMPL                                   \
  {                                                     \
        sword_t  _src;                                  \
   	sword_t _ra,_ca;                               	\
        _ra = ~((sword_t)GPR(RA));                      \
        _ca = PPC_GET_XER_CA;                           \
        if (OVER(_ra,(_ca-1))){    			\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = _ra + _ca -1;      			\
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        if(carrygenerated(_ra,(_ca-1))){		\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }


DEFINST(SUBFMEOD,               	0x5D1,
        "subfmeo.",             	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA)
        



#define ADDME_IMPL                              \
  {                                             \
    SET_GPR(RD, GPR(RA) + PPC_GET_XER_CA - 1 ); \
    if( carrygenerated(GPR(RA), (PPC_GET_XER_CA-1)) ){ \
        PPC_SET_XER_CA;                         \
    }                                           \
    else{ PPC_RESET_XER_CA;}                    \
  }


DEFINST(ADDME,                  	0x1D4,
        "addme",                	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)




#define ADDMED_IMPL                             \
  {                                             \
    sword_t _src;                               \
    sword_t _ra,_ca;                        	\
    _ra = (sword_t)GPR(RA);                     \
    _ca =PPC_GET_XER_CA;                        \
    _src= _ra + _ca-1;                          \
    if( carrygenerated(_ra, (_ca-1)) ){         \
        PPC_SET_XER_CA;                         \
    }                                           \
    else{ PPC_RESET_XER_CA;}                    \
        if(!(_src)) PPC_SET_CR0_EQ;             \
        else PPC_RESET_CR0_EQ;                  \
        if(_src>0) PPC_SET_CR0_GT;              \
        else PPC_RESET_CR0_GT;                  \
        if(_src<0) PPC_SET_CR0_LT;              \
        else PPC_RESET_CR0_LT;                  \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;      \
        else PPC_RESET_CR0_SO;                  \
        SET_GPR(RD, _src);                      \
  }

DEFINST(ADDMED,                 	0x1D5,
        "addme.",               	"d,a,i",
        IntALU,                 	F_ICOMP,   
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA)
    






#define ADDMEO_IMPL                                     \
  {                                                     \
        sword_t _ra,_ca;                        	\
        _ra = GPR(RA);                 			\
	_ca = PPC_GET_XER_CA;				\
	if (OVER(_ra, (_ca-1))){            		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
        SET_GPR(RD, _ra +_ca-1);   			\
        if(carrygenerated(_ra, (_ca-1))){           	\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }
    
DEFINST(ADDMEO,                 	0x5D4,
        "addmeo",               	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)


#define ADDMEOD_IMPL                                    \
  {                                                     \
        sword_t  _src;                                  \
	 sword_t _ra,_ca;                            	\
        _ra = GPR(RA);                                  \
        _ca = PPC_GET_XER_CA;                           \
	if (OVER(_ra,_ca-1)){    			\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = _ra +_ca-1;           			\
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        if(carrygenerated(_ra,(_ca-1))){		\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }




DEFINST(ADDMEOD,                	0x5D5,
        "addmeo.",              	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA)




#define MULLW_IMPL                                      \
  {                                                     \
    sword_t _sw,_sh;                                    \
    sqword_t  _src;                                      \
   _sw = GPR(RA);                                       \
    _sh = GPR(RB);                                      \
    _src = _sw*_sh;                                     \
    SET_GPR(RD, (sword_t)(_src&ULL(0x00000000ffffffff)));    \
   }

DEFINST(MULLW,                  0x1D6,
        "mullw",                "d,a,b",
        IntMULT,                F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), DNA, DNA,
        DNA, DNA, DNA,          DNA, DNA)



#define MULLWO_IMPL                                     \
  {                                                     \
    sword_t _sw,_sh;                                    \
    sqword_t  _src;                                      \
   _sw = GPR(RA);                                       \
    _sh = GPR(RB);                                      \
    _src = _sw*_sh;                                     \
    SET_GPR(RD, (sword_t)(_src&ULL(0x00000000ffffffff)));    \
    if(_src&ULL(0xffffffff00000000)){                        \
        PPC_SET_XER_SO; PPC_SET_XER_OV;                 \
     }                                                  \
     else PPC_RESET_XER_OV;                             \
   }
 
DEFINST(MULLWO,                 	0x5D6,
        "mullwo",               	"d,a,b",
        IntMULT,                	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), DNA, PPC_DXER,
        DNA, DNA, DNA,          	DNA, DNA)




#define MULLWD_IMPL                                     \
  {                                                     \
    sword_t _sw,_sh;                                    \
    sqword_t  _src;                                      \
   _sw = GPR(RA);                                       \
    _sh = GPR(RB);                                      \
    _src = _sw*_sh;                                     \
    SET_GPR(RD, (sword_t)(_src&ULL(0x00000000ffffffff)));    \
       if(!(_src)) PPC_SET_CR0_EQ;                      \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
  }
 
DEFINST(MULLWD,                 	0x1D7,
        "mullw.",               	"d,a,b",
        IntMULT,                	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), DNA, PPC_DCR,
        DNA, DNA, DNA,          	DNA, DNA)



#define MULLWOD_IMPL                                    \
  {                                                     \
    sword_t _sw,_sh;                                    \
    sqword_t  _src;                                      \
   _sw = GPR(RA);                                       \
    _sh = GPR(RB);                                      \
    _src = _sw*_sh;                                     \
    SET_GPR(RD, (sword_t)(_src&ULL(0x00000000ffffffff)));    \
    if(_src&ULL(0xffffffff00000000)){                        \
        PPC_SET_XER_SO; PPC_SET_XER_OV;                 \
     }                                                  \
     else PPC_RESET_XER_OV;                             \
       if(!(_src)) PPC_SET_CR0_EQ;                      \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
   }
 
DEFINST(MULLWOD,                 	0x5D7,
        "mullow.",               	"d,a,b",
        IntMULT,                 	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR, DNA, DNA,           	DNA, DNA)



#define ADD_IMPL					\
  {                                                     \
	SET_GPR(RD, GPR(RA) + GPR(RB));                 \
   }

DEFINST(ADD,                    0x214,
        "add",                  "d,a,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB), DNA,
	DNA,DNA,DNA,		DNA,DNA)



#define ADDD_IMPL                                                      	\
  {                                                                     \
    sword_t  _src;                                                      \
    sword_t _ra,_rb;							\
    _ra = GPR(RA);							\
    _rb = GPR(RB);							\
    _src = _ra + _rb;                                           	\
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
        SET_GPR(RD, _src);                                              \
}
 
DEFINST(ADDD,                   	0x215,
        "add.",                 	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
	DNA,DNA,DNA,			DNA,DNA)





#define ADDO_IMPL					\
  {							\
	sword_t _ra,_rb;                        	\
        _ra = GPR(RA);                 			\
        _rb = GPR(RB);                          	\
	 if (OVER(_ra, _rb)){				\
         	PPC_SET_XER_SO; PPC_SET_XER_OV;	        \
	}						\
	else {PPC_RESET_XER_OV;}			\
        SET_GPR(RD, (_ra + _rb));		        \
  }

DEFINST(ADDO,                   	0x614,
        "addo",                 	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
	DNA,DNA,DNA,			DNA,DNA)



#define ADDOD_IMPL                                      \
  {                                                     \
	sword_t  _src;					\
 	sword_t _ra,_rb;                        	\
        _ra = GPR(RA);                 			\
        _rb = GPR(RB);                 			\
         if (OVER(_ra, _rb)){                   	\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
	 _src = _ra + _rb;				\
        SET_GPR(RD, _src);                 		\
        if(!(_src)) PPC_SET_CR0_EQ;		     	\
        else PPC_RESET_CR0_EQ;				\
        if(_src>0) PPC_SET_CR0_GT;		       	\
        else PPC_RESET_CR0_GT;				\
        if(_src<0) PPC_SET_CR0_LT;		       	\
        else PPC_RESET_CR0_LT;				\
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;	       	\
        else PPC_RESET_CR0_SO;				\
  }
   
DEFINST(ADDOD,                  	0x615,
        "addo.",                	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        PPC_DCR,DNA,DNA,            	PPC_DCR,DNA)




#define EQV_IMPL							\
   {									\
	SET_GPR( RA, ~( (GPR(RS))^(GPR(RB)) ) );			\
   }

DEFINST(EQV,			0x238,
	"eqv",			"a,s,b",
	IntALU,			F_ICOMP,
	PPC_DGPR(RA),DNA,	PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)



#define EQVD_IMPL                                                       \
   {                                                                    \
	word_t _src;							\
	_src= ~( (GPR(RS))^(GPR(RB)) );					\
	SET_GPR( RA, _src);						\
	if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }
    
DEFINST(EQVD,                   0x239,
        "eqv.",                 "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,        	DNA, DNA)



#define XOR_IMPL                                                        \
   {                                                                    \
        SET_GPR(RA, (GPR(RS) ^ GPR(RB)));                               \
   }

DEFINST(XOR,                    0x278,
        "xor",                  "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define XORD_IMPL                                                       \
   {                                                                    \
        sword_t _src;                                                   \
        _src = GPR(RS) ^ GPR(RB);                                       \
        SET_GPR(RA, _src);                                              \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }
    
DEFINST(XORD,                  0x279,
        "xor.",                "a,s,b",
        IntALU,                F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,  PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,         DNA, DNA)
        

#define ORC_IMPL					\
   {							\
        SET_GPR( RA, ( GPR(RS) | (~GPR(RB)) ) );	\
   }
        
DEFINST(ORC,                    0x338,
        "orc",                  "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,          DNA, DNA)

#define ORCD_IMPL				\
   {						\
        sword_t _src;				\
        _src = GPR(RS)| (~(GPR(RB)));		\
        SET_GPR(RA, _src);			\
        if(!(_src)) PPC_SET_CR0_EQ;    		\
        else PPC_RESET_CR0_EQ;			\
        if(_src>0) PPC_SET_CR0_GT;	       	\
        else PPC_RESET_CR0_GT;			\
        if(_src<0) PPC_SET_CR0_LT;	       	\
        else PPC_RESET_CR0_LT;			\
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;    	\
        else PPC_RESET_CR0_SO;			\
   }


DEFINST(ORCD,                  0x339,
        "orc.",                "a,s,b",
        IntALU,                F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,  PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,         DNA, DNA)
 


#define OR_IMPL	                                		        \
   {                                                                    \
        SET_GPR(RA, (GPR(RS) | GPR(RB)));                              	\
   }
   
DEFINST(OR,	                0x378,
        "or",                   "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define ORD_IMPL                                                        \
   {                                                                    \
        sword_t _src;                                                   \
        _src = GPR(RS)| GPR(RB);                                        \
        SET_GPR(RA, _src);                                              \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }

DEFINST(ORD,                   0x379,
        "or.",                 "a,s,b",
        IntALU,                F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,  PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,         DNA, DNA)



#define DIVWU_IMPL                                              \
  {                                                             \
    if (GPR(RB) == 0)                                           \
    {                                                           \
        /*do nothing*/                                          \
    }                                                           \
   else{                                                        \
    SET_GPR(RD, (word_t)GPR(RA) / (word_t)GPR(RB));		\
   }                                                            \
  }
        
DEFINST(DIVWU,                  0x396,
        "divwu",                "d,a,b",
        IntDIV,                 F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB), DNA,
        DNA, DNA, DNA,          DNA, DNA)


#define DIVWUD_IMPL                                             \
 {                                                             \
    word_t  _src;                                               \
    if (GPR(RB) == 0)                                           \
        {                                                       \
                /*do nothing*/                                  \
        }                                                       \
   else{                                                        \
    _src = (word_t)GPR(RA) / (word_t)GPR(RB);			\
        if(!(_src)) PPC_SET_CR0_EQ;                             \
        else PPC_RESET_CR0_EQ;                                  \
        if(_src>0) PPC_SET_CR0_GT;                              \
        else PPC_RESET_CR0_GT;                                  \
        if(_src<0) PPC_SET_CR0_LT;                              \
        else PPC_RESET_CR0_LT;                                  \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                      \
        else PPC_RESET_CR0_SO;                                  \
        SET_GPR(RD, _src);                                      \
      }                                                         \
  }

DEFINST(DIVWUD,                 	0x397,
        "divwu.",               	"d,a,b",
        IntDIV,                 	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
        DNA, DNA, DNA,          	DNA, DNA)



#define DIVWUO_IMPL                                             \
  {                                                             \
    if (GPR(RB) == 0)                                           \
    {                                                           \
        PPC_SET_XER_OV;                                         \
    }                                                           \
   else{                                                        \
        SET_GPR(RD, (word_t)GPR(RA) / (word_t)GPR(RB));		\
        PPC_RESET_XER_OV;                                       \
   }                                                            \
  }
        
DEFINST(DIVWUO,                 	0x796,
        "divwuo",               	"d,a,b",
        IntDIV,                 	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        DNA, DNA, DNA,          	DNA, DNA)




#define DIVWUOD_IMPL                                            \
  {                                                             \
    word_t  _src;                                              	\
    if (GPR(RB) == 0)                                           \
        {                                                       \
        PPC_SET_XER_OV;                                         \
        }                                                       \
   else{                                                        \
        PPC_RESET_XER_OV;                                       \
        _src = (word_t)GPR(RA) / (word_t)GPR(RB);	        \
        if(!(_src)) PPC_SET_CR0_EQ;                             \
        else PPC_RESET_CR0_EQ;                                  \
        if(_src>0) PPC_SET_CR0_GT;                              \
        else PPC_RESET_CR0_GT;                                  \
        if(_src<0) PPC_SET_CR0_LT;                              \
        else PPC_RESET_CR0_LT;                                  \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                      \
        else PPC_RESET_CR0_SO;                                  \
        SET_GPR(RD, _src);                                      \
      }                                                         \
  }

DEFINST(DIVWUOD,                	0x797,
        "divwuo.",              	"d,a,b",
        IntDIV,                 	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
        PPC_DXER, DNA, DNA,         	PPC_DXER, DNA)


#define NAND_IMPL                                                       \
   {                                                                    \
        SET_GPR(RA, ~(GPR(RS)& GPR(RB)));                               \
   }
   
DEFINST(NAND,                   0x3B8,
        "nand",                 "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define NANDD_IMPL                                                      \
   {                                                                    \
        sword_t _src;                                                   \
        _src = ~(GPR(RS)& GPR(RB));                                     \
        SET_GPR(RA, _src);                                              \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }

DEFINST(NANDD,                  0x3B9,
        "nand.",                "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,        	DNA, DNA)





#define EXTSB_IMPL							\
   {									\
   	SET_GPR( RA, SEXT8( GPR(RS) & 0xff ) );				\
   }

DEFINST(EXTSB,			0x774,
	"extsb",		"a,s",
	IntALU,			F_ICOMP,
	PPC_DGPR(RA),DNA,	PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define EXTSBD_IMPL                                                     \
   {                                                                    \
	word_t _src;                                                    \
        _src= SEXT8(GPR(RS)&0xff);                             		\
        SET_GPR( RA, _src);                                             \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }

DEFINST(EXTSBD,                 0x775,
        "extsb.",               "a,s",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define EXTSH_IMPL                                                      \
   {                                                                    \
        SET_GPR( RA, SEXT16(GPR(RS)&0xffff) );             		\
   }

DEFINST(EXTSH,                  0x734,
        "extsh",                "a,s",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)



#define EXTSHD_IMPL                                                     \
   {                                                                    \
        word_t _src;                                                    \
        _src= SEXT16(GPR(RS)&0xffff);                                   \
        SET_GPR( RA, _src);                                             \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }
        
DEFINST(EXTSHD,                 0x735,
        "extsh.",               "a,s",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)



/*This does not generate a divide by zero exception so the body is
left blank. If there are modfications, they can be pulgged easily*/

#define DIVW_IMPL               	                        \
  {                                                             \
    if (GPR(RB) == 0)  						\
    {								\
	/*do nothing*/						\
    }								\
    else if( ((sword_t)GPR(RB)==(-1)) && ((word_t)GPR(RA)==0x80000000) )\
	 {							\
	/*do nothing*/						\
	}							\
   else{							\
    SET_GPR(RD, GPR(RA) / GPR(RB));				\
   }								\
  }

DEFINST(DIVW,                   0x3D6,
        "divw",                 "d,a,b", 
        IntDIV,                 F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB), DNA,
        DNA, DNA, DNA,        	DNA, DNA)





#define DIVWO_IMPL                                              \
  {                                                             \
    if (GPR(RB) == 0)                                           \
    {                                                           \
	PPC_SET_XER_OV;						\
    }                                                           \
    else if( ((sword_t)GPR(RB)==(-1)) && ((word_t)GPR(RA)==0x80000000) )\
    {                                                           \
	PPC_SET_XER_OV;						\
     }                                                          \
   else{                                                        \
    	SET_GPR(RD, GPR(RA) / GPR(RB));                         \
	PPC_RESET_XER_OV;				      	\
   }    	                                                \
  }

 
DEFINST(DIVWO,                  0x7D6,
        "divwo",                "d,a,b",
        IntDIV,                 F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        DNA, DNA, DNA,          DNA, DNA)






#define DIVWD_IMPL	                                        \
  {                                                             \
    sword_t  _src;					 	\
    if (GPR(RB) == 0)                                           \
    	{                                                       \
        	/*do nothing*/                                  \
    	}                                                       \
    else if( ((sword_t)GPR(RB)==(-1)) && ((word_t)GPR(RA)==0x80000000) )\
         {                                                      \
        /*do nothing*/                                          \
        }                                                       \
   else{                                                        \
    _src = GPR(RA) / GPR(RB);                                   \
        if(!(_src)) PPC_SET_CR0_EQ;                             \
        else PPC_RESET_CR0_EQ;                                  \
        if(_src>0) PPC_SET_CR0_GT;                              \
        else PPC_RESET_CR0_GT;                                  \
        if(_src<0) PPC_SET_CR0_LT;                              \
        else PPC_RESET_CR0_LT;                                  \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                      \
        else PPC_RESET_CR0_SO;                                  \
	SET_GPR(RD, _src);                                 	\
      }								\
  }

DEFINST(DIVWD,                  	0x3D7,
        "divw.",                	"d,a,b",
        IntDIV,                 	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
        DNA, DNA, DNA,        		DNA, DNA)






#define DIVWOD_IMPL						\
  {                                                             \
    sword_t  _src;                                              \
    if (GPR(RB) == 0)                                           \
        {                                                       \
	PPC_SET_XER_OV;						\
        }                                                       \
    else if( ((sword_t)GPR(RB)==(-1)) && ((word_t)GPR(RA)==0x80000000) )\
         {                                                      \
	PPC_SET_XER_OV;						\
        }                                                       \
   else{                                                        \
	PPC_RESET_XER_OV;					\
        _src = GPR(RA) / GPR(RB);                               \
        if(!(_src)) PPC_SET_CR0_EQ;                             \
        else PPC_RESET_CR0_EQ;                                  \
        if(_src>0) PPC_SET_CR0_GT;                              \
        else PPC_RESET_CR0_GT;                                  \
        if(_src<0) PPC_SET_CR0_LT;                              \
        else PPC_RESET_CR0_LT;                                  \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                      \
        else PPC_RESET_CR0_SO;                                  \
        SET_GPR(RD, _src);                                      \
      }                                                         \
  }

DEFINST(DIVWOD,                 	0x7D7,
        "divwo.",               	"d,a,b",
        IntDIV,                 	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
        PPC_DXER, DNA, DNA,         	PPC_DXER, DNA)
 

CONNECT(FDIVS_LINK)

#define FDIVS_IMPL                                      \
  {                                                     \
   qword_t _a, _b;                               \
   qword_t *dest;                             \
   double double_a, double_b, double_dest;                     \
	int *x1, *x2;											\
   _a = PPC_FPR_DW(RA);                                \
   _b = PPC_FPR_DW(RB);                                \
	memcpy(&double_a, &_a, sizeof(double) );				\
	memcpy(&double_b, &_b, sizeof(double) );				\
	x1 = (int *) &double_dest;                         \
   x2 = ((int *) &double_dest)+1;                           \
   dest = (qword_t *) (&double_dest);                           \
	double_dest = (double)((float)( double_a / double_b));			\
   dest = (qword_t *) (&double_dest);                           \
   PPC_SET_FPR_DW(FD, *dest);                                  \
  }
                                                         
DEFINST(FDIVS,                  0x24,
        "fdivs",                "D,A,B",
        FloatDIV,               F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,  PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        DNA, DNA, DNA,          DNA, DNA)


#define FDIVSD_IMPL                                     \
  {                                                     \
	 FDIVS_IMPL;											\
    PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }

DEFINST(FDIVSD,                 	0x25,
        "fdivs.",               	"D,A,B",
        FloatDIV,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)

#define FSUBS_IMPL                                      \
  {                                                     \
	qword_t _a, _dest, _b;                               \
   qword_t *dest;                             \
   double double_a, double_b, double_dest;                     \
   _a = PPC_FPR_DW(RA);                                \
   _b = PPC_FPR_DW(RB);                                \
  	memcpy(&double_a, &_a, sizeof(double) );		\
  	memcpy(&double_b, &_b, sizeof(double) );		\
   double_dest = (double) ((float) double_a - double_b); 		\
   dest = (qword_t *) (&double_dest);         \
   PPC_SET_FPR_DW(FD, *dest);                              \
  }
        
DEFINST(FSUBS,                  	0x28,   
        "fsubs",                	"D,A,B",
        FloatADD,               	F_FCOMP, 
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        DNA, DNA, DNA,          	DNA, DNA)




#define FSUBSD_IMPL                                     \
  {                                                     \
	 FSUBS_IMPL;													  \
    PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }

DEFINST(FSUBSD,                 	0x29,
        "fsubs.",               	"D,A,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)




#define FADDS_IMPL                                      \
  {                                                     \
   qword_t _a, _dest, _b;                               \
   qword_t *dest;                             \
   double double_a, double_b, double_dest;                     \
   _a = PPC_FPR_DW(RA);                                \
   _b = PPC_FPR_DW(RB);                                \
	memcpy(&double_a, &_a, sizeof(double) );				\
	memcpy(&double_b, &_b, sizeof(double) );				\
   double_dest = (double) ((float) (double_a + double_b));      \
   dest = (qword_t *) (&double_dest);         \
   PPC_SET_FPR_DW(FD, *dest);                            \
  }

DEFINST(FADDS,                  	0x2A,
        "fadds",                	"D,A,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        DNA, DNA, DNA,          	DNA, DNA)
                


#define FADDSD_IMPL                                     \
  {                                                     \
   FADDS_IMPL               \
   PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000));   \
  }

DEFINST(FADDSD,                 	0x2B,
        "fadds.",               	"D,A,B",
        FloatADD,       		F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)



#define FMULS_IMPL                                      \
  {                                                     \
   qword_t _a, _c;                               \
   qword_t *dest;                             \
   double double_a, double_c, double_dest;                     \
   _a = PPC_FPR_DW(RA);                                \
   _c = PPC_FPR_DW(RC);                                \
	memcpy(&double_a, &_a, sizeof(double) );				\
	memcpy(&double_c, &_c, sizeof(double) );				\
   double_dest = (double) ((float) (double_a * double_c));     \
   dest = (qword_t *) (&double_dest);         \
	PPC_SET_FPR_DW(FD, *dest);                              \
  }
        
DEFINST(FMULS,                  	0x32,
        "fmuls",                	"D,A,C",
        FloatMULT,              	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FC), PPC_DFPSCR,
        DNA, DNA, DNA,          	DNA, DNA)


#define FMULSD_IMPL                                     \
  {                                                     \
		FMULS_IMPL;														\
      PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }

DEFINST(FMULSD,                 	0x33,
        "fmuls.",               	"D,A,C",
        FloatMULT,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FC), PPC_DFPSCR,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)
  




#define FRES_IMPL					\
   {							\
	qword_t _a;                               \
   qword_t *dest;                             \
   double double_a, double_b, double_dest;                     \
	float fdest;							\
   _a = PPC_FPR_DW(FB);                                \
	memcpy(&double_a, &_a, sizeof(double) );	\
	fdest = (float) 1.0/_a;			\
	double_dest = (double) fdest;	\
   dest = (qword_t *) (&double_dest);         \
   PPC_SET_FPR_DW(FD, *dest);                              \
	}

DEFINST(FRES,				0x30,
	"fres",				"D,B",
	FloatDIV,			F_FCOMP,
	PPC_DFPR(FD), PPC_DFPSCR,	PPC_DFPR(FB), PPC_DFPSCR,DNA,
	DNA, DNA, DNA,			DNA,DNA)


#define FRESD_IMPL					\
   {							\
	qword_t _b,_fc,_fd;      			\
        word_t _fp;                                     \
	dfloat_t _fb;					\
	qword_t _a;       				\
	_b =  PPC_FPR_DW(FB);				\
	_fb = PPC_FPR(FB);				\
	if(_b==NEGINFSP){				\
		 PPC_SET_FPR_DW(FD,NEGZEROSP);	     	\
		 PPC_SET_FPSCR_FPRF(0x12);		\
	}						\
	else if(_b==POSINFSP){				\
		 PPC_SET_FPR_DW(FD,POSZEROSP);		\
		 PPC_SET_FPSCR_FPRF(0x02);		\
	}						\
	else if(_b==NEGZEROSP){				\
		 PPC_SET_FPR_DW(FD,NEGINFSP);		\
		 PPC_SET_FPSCR_ZX;			\
		 PPC_SET_FPSCR_FX;			\
		 PPC_SET_FPSCR_FPRF(0x09);		\
	}						\
	else if(_b==POSZEROSP){				\
	 	PPC_SET_FPR_DW(FD,POSINFSP);		\
		PPC_SET_FPSCR_ZX;			\
		PPC_SET_FPSCR_FX;			\
		PPC_SET_FPSCR_FPRF(0x3);		\
	}						\
	else if(isspSNan(_b)){				\
		PPC_SET_FPR_DW(FD,_b|ULL(0x0008000000000000));	\
		PPC_SET_FPSCR_VXSNAN;			\
		PPC_SET_FPSCR_FX;			\
		PPC_SET_FPSCR_FPRF(0x11);		\
	}						\
	else if(isspQNan(_b)){				\
		PPC_SET_FPR_DW(FD,_b);      		\
                PPC_SET_FPSCR_FPRF(0x11);               \
	}						\
	else {						\
		_fb=1.0/_fb;				\
		_fp=FPSCR;				\
                _fc=*(qword_t*)(&_fb);                   \
                ieee_CVTTS((_fp&0x3),_fc,&_fd,&_fp);    \
                PPC_SET_FPSCR(_fp);                     \
                PPC_SET_FPR_DW(FD,_fd);                 \
		_a = *(qword_t*)(& _fb);		        \
		if(_fb<0.0){				\
			if(_a&ULL(0x7f80000000000000)) PPC_SET_FPSCR_FPRF(0x8);\
			else PPC_SET_FPSCR_FPRF(0x18);	\
		}					\
		else{					\
			if(_a&ULL(0x7f80000000000000)) PPC_SET_FPSCR_FPRF(0x4);\
                        else PPC_SET_FPSCR_FPRF(0x14);	\
		}					\
	}						\
        PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
   }

DEFINST(FRESD,				0x31,
	"fres.",			"D,B",
	FloatDIV,			F_FCOMP,
	PPC_DFPR(FD), PPC_DFPSCR,	PPC_DFPR(FB), PPC_DFPSCR,DNA,
	PPC_DCR, DNA, DNA,		DNA,DNA)




#define FNMSUBS_IMPL                                    \
  {                                                     \
	qword_t _a, _b,_c;                         \
   double double_a, double_b, double_c;            \
   double double_dest;                             \
   qword_t *dest;                                   \
   _a = PPC_FPR_DW(FA);                            \
   _b = PPC_FPR_DW(FB);                            \
   _c = PPC_FPR_DW(FC);          \
	memcpy(&double_a, &_a, sizeof(double) );	\
	memcpy(&double_b, &_b, sizeof(double) );	\
	memcpy(&double_c, &_c, sizeof(double) );	\
   double_dest = (double) ((float) (-(double_a * double_c - double_b)));     \
   dest = (qword_t *) (&double_dest);               \
   PPC_SET_FPR_DW(FD, *dest);                          \
  }
        
DEFINST(FNMSUBS,                      0x3C,
        "fnmsubs",                    "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA,                PPC_DFPSCR, DNA)




#define FNMSUBSD_IMPL                                   \
  {                                                     \
	FNMSUBS_IMPL;													\
        PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }

DEFINST(FNMSUBSD,                     0x3D,
        "fnmsubs.",                   "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        PPC_DCR, DNA, DNA,            PPC_DFPSCR, PPC_DCR)


#define FMSUBS_IMPL                                     \
  {                                                     \
	qword_t _a, _b,_c;                         \
   double double_a, double_b, double_c;            \
   double double_dest;                             \
   qword_t *dest;                                   \
   _a = PPC_FPR_DW(FA);                            \
   _b = PPC_FPR_DW(FB);                            \
   _c = PPC_FPR_DW(FC);          \
	memcpy(&double_a, &_a, sizeof(double) );		\
	memcpy(&double_b, &_b, sizeof(double) );		\
	memcpy(&double_c, &_c, sizeof(double) );		\
   double_dest = (double) ((float) (double_a * double_c - double_b ));     \
   dest = (qword_t *) (&double_dest);               \
   PPC_SET_FPR_DW(FD, *dest);                          \
  }

DEFINST(FMSUBS,                       0x38,   
        "fmsubs",                     "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA,                PPC_DFPSCR, DNA)

#define FMSUBSD_IMPL                                    \
  {                                                     \
	  FMSUBS_IMPL;													\
     PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }
   
DEFINST(FMSUBSD,                      0x39,
        "fmsubs.",                    "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        PPC_DCR, DNA, DNA,            PPC_DFPSCR, PPC_DCR)





#define FMADDS_IMPL                                     \
  {                                                     \
	qword_t _a, _b,_c;                         \
   double double_a, double_b, double_c;            \
   double double_dest;                             \
   qword_t *dest;                                   \
   _a = PPC_FPR_DW(FA);                            \
   _b = PPC_FPR_DW(FB);                            \
   _c = PPC_FPR_DW(FC);          \
	memcpy(&double_a, &_a, sizeof(double) ); 	\
	memcpy(&double_a, &_a, sizeof(double) ); 	\
	memcpy(&double_a, &_a, sizeof(double) ); 	\
   double_dest = (double) ((float) (double_a * double_c + double_b));   \
   dest = (qword_t *) (&double_dest);               \
   PPC_SET_FPR_DW(FD, *dest);                          \
  }
        
DEFINST(FMADDS,                 	0x3A,
        "fmadds",               	"D,A,C,B",
        FloatMULT,     	F_FCOMP, 
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA,          	PPC_DFPSCR, DNA)




#define FMADDSD_IMPL                                    \
  {                                                     \
	FMADDS_IMPL;													\
   PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }
   
DEFINST(FMADDSD,                      0x3B,
        "fmadds.",                    "D,A,C,B",    
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        PPC_DCR, DNA, DNA,            PPC_DFPSCR, PPC_DCR)



        
#define FNMADDS_IMPL                                    \
  {                                                     \
	qword_t _a, _b,_c;                         \
   double double_a, double_b, double_c;            \
   double double_dest;                             \
   qword_t *dest;                                   \
   _a = PPC_FPR_DW(FA);                            \
   _b = PPC_FPR_DW(FB);                            \
   _c = PPC_FPR_DW(FC);          \
	memcpy(&double_a, &_a, sizeof(double) ); \
	memcpy(&double_b, &_b, sizeof(double) ); 	\
	memcpy(&double_c, &_c, sizeof(double) ); 	\
   double_dest = (double)((float) (-(double_a * double_c + double_b)));   \
   dest = (qword_t *) (&double_dest);               \
   PPC_SET_FPR_DW(FD, *dest);                          \
  }

DEFINST(FNMADDS,                      0x3E,
        "fnmadds",                    "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA,                PPC_DFPSCR, DNA)



#define FNMADDSD_IMPL                                    \
  {                                                     \
   FNMADDS_IMPL;				\
	PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }

DEFINST(FNMADDSD,                     0x3F,
        "fnmadds.",                   "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        PPC_DCR, DNA, DNA,            PPC_DFPSCR, PPC_DCR)





#define FSQRTS_IMPL					\
   {							\
	qword_t _a;                               \
   qword_t *dest;                             \
   double double_a, double_dest;                     \
   _a = PPC_FPR_DW(FB);                                \
	memcpy(&double_a, &_a, sizeof(double) ); \
	double_dest = (double) ((float) sqrt(double_a)) ;	\
   dest = (qword_t *) (&double_dest);         \
   PPC_SET_FPR_DW(FD, *dest);                              \
   }

DEFINST(FSQRTS,			        0x2C,
	"fsqrts",			"D,B",
	FloatSQRT,			F_FCOMP,
	PPC_DFPR(FD), PPC_DFPSCR,	PPC_DFPR(FB), PPC_DFPSCR,DNA,
	DNA, DNA, DNA,			DNA,DNA)


#define FSQRTSD_IMPL					\
   {							\
		FSQRTS_IMPL;							\
        PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
   }

DEFINST(FSQRTSD,			0x2D,
	"fsqrts.",			"D,B",
	FloatSQRT,			F_FCOMP,
	PPC_DFPR(FD), PPC_DFPSCR,	PPC_DFPR(FB), PPC_DFPSCR,DNA,
	PPC_DCR, DNA, DNA,		DNA,DNA)


CONNECT(FCMPU_LINK)


#define FCMPU_IMPL                                      \
   {                                                    \
	dfloat_t _fa,_fb;                               \
	word_t _c,_cr;                                  \
	qword_t _a, _b;                                \
        _fa=PPC_FPR(RA);                                \
        _fb=PPC_FPR(RB);                                \
        _a=PPC_FPR_DW(RA);                              \
        _b=PPC_FPR_DW(RB);                              \
        if(isdpNan(_a)||isdpNan(_b)){                   \
                _c=1;                                   \
        }                                               \
        else if(_fa<_fb) _c = 8;                        \
        else if(_fa>_fb) _c = 4;                        \
        else _c =2;                                     \
        PPC_SET_FPSCR_FPCC(_c);                         \
        _cr = (CR & (~(0xf<<((7-CRFD)*4)))) | (_c <<((7-CRFD)*4));    \
        PPC_SET_CR(_cr);                                \
                                                        \
        if(isdpSNan(_a)||isdpSNan(_b)){                 \
               PPC_SET_FPSCR_VXSNAN;                    \
        }                                               \
   }
    
DEFINST(FCMPU,                  0x0,
        "fcmpu",                "r,A,B",
        FloatCMP,               F_FCOMP,
        PPC_DFPSCR,PPC_DCR,     PPC_DFPR(RA),PPC_DFPR(RB),PPC_DFPSCR,
        DNA,DNA,DNA,            PPC_DCR,DNA)



#define FCMPO_IMPL					\
   {							\
	dfloat_t _fa,_fb;			        \
	qword_t   _a, _b;				\
        word_t  _c,_cr;                                 \
	_fa=PPC_FPR(RA);				\
	_fb=PPC_FPR(RB);		      		\
	_a=PPC_FPR_DW(RA);				\
	_b=PPC_FPR_DW(RB);			     	\
	if(isdpNan(_a)||isdpNan(_b)){			\
		_c=1;					\
	}						\
	else if(_fa<_fb) _c = 8;			\
	else if(_fa>_fb) _c = 4;			\
	else _c =2;					\
	PPC_SET_FPSCR_FPCC(_c);				\
	_cr = (CR & (~(0xf<<((7-CRFD)*4)))) | (_c <<((7-CRFD)*4));	\
	PPC_SET_CR(_cr);				\
							\
	if(isdpSNan(_a)||isdpSNan(_b)){			\
               PPC_SET_FPSCR_VXSNAN;			\
		if(PPC_GET_FPSCR_VE==0) PPC_SET_FPSCR_VXVC;	\
        }						\
	else if(isdpQNan(_a)||isdpQNan(_b)){		\
                PPC_SET_FPSCR_VXVC;           		\
        }						\
   }

DEFINST(FCMPO,			0x040,
	"fcmpo",		"r, A, B",
	FloatCMP,		F_FCOMP,
	PPC_DFPSCR,PPC_DCR,	PPC_DFPR(RA),PPC_DFPR(RB),PPC_DFPSCR,
	DNA,DNA,DNA,		PPC_DCR,DNA)




#define MCRFS_IMPL							\
   {									\
	word_t _f, _m, _c, _cr;						\
	_cr = CRFS;                                                     \
	_m=  ( 0xf << ((7-_cr)*4) );					\
	_f= FPSCR & _m;							\
	_c = (CR & (~ (_m))) | _f;					\
									\
	if(_cr==0){							\
	PPC_RESET_FPSCR_FX;				       		\
	PPC_RESET_FPSCR_OX;				       		\
	}								\
	else if(_cr==1){						\
	PPC_RESET_FPSCR_UX;				       		\
	PPC_RESET_FPSCR_ZX;				       		\
	PPC_RESET_FPSCR_ZX;				       		\
	PPC_RESET_FPSCR_VXSNAN;						\
        }								\
        else  if(_cr==2){						\
    	PPC_RESET_FPSCR_VXISI;						\
    	PPC_RESET_FPSCR_VXIDI;						\
    	PPC_RESET_FPSCR_VXZDZ;						\
    	PPC_RESET_FPSCR_VXIMZ;						\
        }								\
        else  if(_cr==3){						\
        PPC_RESET_FPSCR_VXVC;						\
        }								\
        else  if(_cr==5){						\
        PPC_RESET_FPSCR_VXSOFT;						\
        PPC_RESET_FPSCR_VXSQRT;						\
        PPC_RESET_FPSCR_VXCVI;						\
        }								\
   }


DEFINST(MCRFS,			0x080,
	"mcrfs",		"r,w",
	IntALU,			F_ICOMP,
	PPC_DFPSCR,PPC_DCR,	PPC_DFPSCR,PPC_DCR,DNA,
        DNA, DNA, DNA,		DNA, DNA)

#define FRSP_IMPL                                     \
{                                                     \
   qword_t _d;                               \
   qword_t *dest;                             \
   double double_a, double_dest;                     \
   float tempf;					\
   int *fp1;                              \
   word_t *ptempf;                              \
   int *a, *b;\
	a = (int *) &double_dest;    \
        b = (int *) &double_dest;  b++;\
   _d = PPC_FPR_DW(RB); 			\
   memcpy(&double_a, &_d, sizeof(double) ); 	\
   tempf = (float) double_a;  \
   double_dest = (double) tempf;		\
   dest = (qword_t *) (&double_dest);         \
   PPC_SET_FPR_DW(FD, *dest);                              \
}
        

DEFINST(FRSP,                   	0x018,
        "frsp",                 	"D,B",
        FloatADD,               	F_FCOMP,   
        PPC_DFPR(FD),PPC_DFPSCR,        PPC_DFPR(FB),PPC_DFPSCR,DNA,
        DNA, DNA, DNA,          	DNA, DNA)


#define FRSPD_IMPL                                      \
  {                                                     \
	FRSP_IMPL													\
   PPC_SET_CR((CR&0xf0ffffff)|(FPSCR&0x0f000000));	\
  }     
  

DEFINST(FRSPD,                  	0x019,
        "frsp.",                	"D,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD),PPC_DFPSCR,        PPC_DFPR(FB),PPC_DFPSCR,DNA,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)

#ifdef FP_ROUND_CONVERSION_INST

#define FCTIW_IMPL					\
  {						\
	qword_t _b;                               \
   qword_t *dest;                             \
   word_t temp;				\
   qword_t res;				\
   double double_b, double_dest;                     \
   _b = PPC_FPR_DW(RB);                                \
   memcpy(&double_b, &_b, sizeof(double) );	\
   temp = (int) double_b;			\
   memcpy(&res, &temp, sizeof(int) );		\
   temp = 0;					\
   memcpy((word_t *)&res+1, &temp, sizeof(int) );	\
   memcpy(&double_dest, &res, sizeof(double) ); 	\
   dest = (qword_t *) (&double_dest);         \
   PPC_SET_FPR_DW(FD, *dest);                              \
  }

#else

#define FCTIW_IMPL               \
{					\
	fprintf(stderr, "ALERT:  FCTIW instruction not implemented on this machine! unable to inline. quitting.\n"); exit(1);			\
}

#endif

DEFINST(FCTIW,                  	0x01C,
        "fctiw",                	"D,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD),PPC_DFPSCR,        PPC_DFPR(FB),PPC_DFPSCR,DNA,
        DNA, DNA, DNA,        		DNA,DNA)

#define FCTIWD_IMPL					\
  {							\
	FCTIW_IMPL										\
   PPC_SET_CR((CR&0xf0ffffff)|(FPSCR&0x0f000000));	\
  }

DEFINST(FCTIWD,                 	0x01D,
        "fctiw.",               	"D,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD),PPC_DFPSCR,        PPC_DFPR(FB),PPC_DFPSCR,DNA,
        PPC_DCR, DNA, DNA,        	PPC_DCR, DNA)


#ifdef FP_ROUND_CONVERSION_INST

#define FCTIWZ_IMPL					\
  {							\
   qword_t _b;                               \
   qword_t *dest;                             \
   word_t temp;				\
   qword_t res;				\
   double double_b, double_dest;                     \
   _b = PPC_FPR_DW(RB);                                \
   memcpy(&double_b, &_b, sizeof(double) );	\
   temp = (int) double_b;			\
   memcpy(&res, &temp, sizeof(int) );		\
   temp = 0;					\
   memcpy((word_t *)&res+1, &temp, sizeof(int) );	\
   memcpy(&double_dest, &res, sizeof(double) ); \
   dest = (qword_t *) (&double_dest);         \
   PPC_SET_FPR_DW(FD, *dest);                              \
  }

#else

#define FCTIWZ_IMPL 					\
{			\
	fprintf(stderr, "ALERT:  FCTIWZ instruction not implemented on this machine! unable to inline. quitting.\n"); 		\
	printf("PC %x\n", regs.regs_PC);		\
	exit(1);        \
}

#endif

DEFINST(FCTIWZ,                 	0x1E,
        "fctiwz",               	"D,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD),PPC_DFPSCR,        PPC_DFPR(FB),PPC_DFPSCR,DNA,
        DNA, DNA, DNA,        		DNA, DNA)

#define FCTIWZD_IMPL					\
  {							\
	FCTIWZ_IMPL												\
   PPC_SET_CR((CR&0xf0ffffff)|(FPSCR&0x0f000000));		\
  }


DEFINST(FCTIWZD,                	0x1F,
        "fctiwzd",              	"D,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD),PPC_DFPSCR,        PPC_DFPR(FB),PPC_DFPSCR,DNA,
        PPC_DCR, DNA, DNA,        	PPC_DCR, DNA)

#define FDIV_IMPL                                      	\
  {                                                     \
   qword_t _a, _b;                               \
   qword_t *dest;                             \
   double double_a, double_b, double_dest;                     \
   _a = PPC_FPR_DW(RA);                                \
   _b = PPC_FPR_DW(RB);                                \
	memcpy(&double_a, &_a, sizeof(double) );	\
	memcpy(&double_b, &_b, sizeof(double) );	\
   double_dest = double_a / double_b;      \
   dest = (qword_t *) (&double_dest);         						\
   PPC_SET_FPR_DW(FD, *dest);                              		\
  }
        
DEFINST(FDIV,                   	0x24,
        "fdiv",                 	"D,A,B",
        FloatDIV,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        DNA, DNA, DNA,          	DNA, DNA)
        

#define FDIVD_IMPL                                     	\
  {                                                     \
	FDIV_IMPL									\
   PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }

DEFINST(FDIVD,                  	0x25,
        "fdiv.",                	"D,A,B",
        FloatDIV,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)



#define MTFSB1_IMPL                                                     \
   {                                                                    \
        word_t _m, _f;                                                  \
        _m =  0x1 << (31 - CRBD);                                       \
        _f = FPSCR | _m;                                           	\
        if(!((CRBD==1) || (CRBD == 2)))                                 \
        {                                                               \
                PPC_SET_FPSCR(_f);                                      \
        }                                                               \
   }


DEFINST(MTFSB1,                 0x04C,
        "mtfsb1",               "frd",
        IntALU,                 F_ICOMP,
        PPC_DFPSCR,DNA,         PPC_DFPSCR,DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define MTFSB1D_IMPL                                                    \
   {                                                                    \
        word_t _m, _f, _c;                                              \
        _m =  0x1 << (31 - CRBD);                                       \
        _f = FPSCR | _m;                                           	\
        if(!((CRBD==1) || (CRBD == 2)))                                 \
        {                                                               \
                PPC_SET_FPSCR(_f);                                      \
        }                                                               \
        _c = CR;                                                        \
        PPC_SET_CR( (_c & 0xf0ffffff) | (_f & 0x0f000000) );            \
   }
        
    
DEFINST(MTFSB1D,                0x4D,
        "mtfsb1.",              "D",
        IntALU,                 F_ICOMP,
        PPC_DFPSCR,PPC_DCR,     PPC_DFPSCR,PPC_DCR,DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define FNEG_IMPL                                                      \
   {                                                                   \
         PPC_SET_FPR_D( FD, ( -PPC_FPR(FB) ) );	                       \
   }    

DEFINST(FNEG,                   0x050,
        "fneg",                 "D,B",
        FloatADD,               F_FCOMP,
        PPC_DFPR(FD), DNA,      PPC_DFPR(FB), DNA, DNA,
        DNA, DNA, DNA,          DNA, DNA)



#define FNEGD_IMPL                                                      \
   {                                                                    \
        PPC_SET_FPR_D( FD, ( -PPC_FPR(FB) ) );                          \
	PPC_SET_CR( (CR & 0xf0ffffff) | (((FPSCR)>>4) & 0x0f000000)  );	\
   }
    
DEFINST(FNEGD,                  0x051,
        "fneg.",                "D,B",
        FloatADD,               F_FCOMP, 
        PPC_DFPR(FD), DNA,      PPC_DFPR(FB), PPC_DFPSCR, PPC_DCR,
        DNA, DNA, DNA,         	DNA, DNA)

#define MTFSB0_IMPL                                                     \
   {                                                                    \
	word_t _m, _f;							\
	_m =  0x1 << (31 - CRBD);					\
	_f = FPSCR & (~(_m));						\
	if(!((CRBD==1) || (CRBD == 2)))					\
	{								\
		PPC_SET_FPSCR(_f);					\
	}								\
   }
        
    
DEFINST(MTFSB0,                 0x8C,
        "mtfsb0",               "D",
        IntALU,                 F_ICOMP,
        PPC_DFPSCR,DNA,         PPC_DFPSCR,DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define MTFSB0D_IMPL                                                    \
   {                                                                    \
        word_t _m, _f, _c;                                              \
        _m =  0x1 << (31 - CRBD);                                       \
        _f = FPSCR & (~(_m));                                           \
        if(!((CRBD==1) || (CRBD == 2)))                                 \
        {                                                               \
                PPC_SET_FPSCR(_f);                                      \
        }                                                               \
        _c = CR;                                                        \
        PPC_SET_CR( (_c & 0xf0ffffff) | (_f & 0x0f000000) );            \
   }


DEFINST(MTFSB0D,                0x8D,   
        "mtfsb0.",              "D",  
        IntALU,                 F_ICOMP,
        PPC_DFPSCR,PPC_DCR,     PPC_DFPSCR,PPC_DCR,DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define FMR_IMPL							\
   {									\
	PPC_SET_FPR_D(FD, PPC_FPR(FB));					\
   }

DEFINST(FMR,			0x090,
	"fmr",			"D,B",
	FloatADD,		F_FCOMP,
	PPC_DFPR(FD), DNA,      PPC_DFPR(FB), DNA, DNA,
        DNA, DNA, DNA,          DNA, DNA)

#define FMRD_IMPL                                                       \
   {                                                                    \
        PPC_SET_FPR_D(FD, PPC_FPR(FB));                                 \
	PPC_SET_CR( (CR & 0xf0ffffff) | (((FPSCR)>>4) & 0x0f000000)  ); \
   }

DEFINST(FMRD,                   0x091,
        "fmr.",                 "D,B",
        FloatADD,               F_FCOMP,
        PPC_DFPR(FD), DNA,      PPC_DFPR(FB), PPC_DFPSCR, PPC_DCR,
        DNA, DNA, DNA,          DNA, DNA)

#define FSUB_IMPL                                       \
  {                                                     \
   qword_t _a, _b;                               \
   qword_t *dest;                             \
   double double_a, double_b, double_dest;                     \
   _a = PPC_FPR_DW(RA);                                \
   _b = PPC_FPR_DW(RB);                                \
	memcpy(&double_a, &_a, sizeof(double) );			\
	memcpy(&double_b, &_b, sizeof(double) );			\
	double_dest = double_a - double_b;					\
   dest = (qword_t *) (&double_dest);         \
   PPC_SET_FPR_DW(FD, *dest);                              \
  }
        
DEFINST(FSUB,                   	0x28,
        "fsub",                 	"D,A,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        DNA, DNA, DNA,          	DNA, DNA)


#define FSUBD_IMPL                                      \
  {                                                     \
		FSUB_IMPL										\
      PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }

DEFINST(FSUBD,                  	0x29,
        "fsub.",                	"D,A,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)




#define FADD_IMPL					\
  { 							\
   qword_t _a, _b;                               \
   qword_t *dest;                             \
   double double_a, double_b, double_dest;                     \
   _a = PPC_FPR_DW(RA);                                \
   _b = PPC_FPR_DW(RB);                                \
	memcpy(&double_a, &_a, sizeof(double) );	\
	memcpy(&double_b, &_b, sizeof(double) );	\
	double_dest = double_a + double_b;	\
   dest = (qword_t *) (&double_dest);         \
   PPC_SET_FPR_DW(FD, *dest);                              \
  }

DEFINST(FADD,                   	0x2A,
        "fadd",                 	"D,A,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        DNA, DNA, DNA,         		DNA, DNA)

#define FADDD_IMPL					\
  {                                                     \
	FADD_IMPL					\
	PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000));	\
  }


DEFINST(FADDD,                  	0x2B,
        "fadd.",                	"D,A,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)




#define FSEL_IMPL				\
   {						\
	if(PPC_FPR(FA)>=0.0){			\
		PPC_SET_FPR_D(FD,PPC_FPR(FC));	\
	}					\
	else{					\
		PPC_SET_FPR_D(FD,PPC_FPR(FB));  \
	}					\
   }

DEFINST(FSEL,			0x2E,
	"fsel",			"D,A,C,B",
	FloatCMP,		F_FCOMP,
	PPC_DFPR(FD),DNA,	PPC_DFPR(FA),PPC_DFPR(FB),PPC_DFPR(FC),
	DNA,DNA,DNA,		DNA,DNA)

#define FSELD_IMPL                              \
   {                                            \
        if(PPC_FPR(FA)>=0.0){                   \
                PPC_SET_FPR_D(FD,PPC_FPR(FC));  \
        }                                       \
        else{                                   \
                PPC_SET_FPR_D(FD,PPC_FPR(FB));  \
        }                                       \
        PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
   }
    
DEFINST(FSELD,                  0x2F,
        "fsel.",                "D,A,C,B",
        FloatCMP,               F_FCOMP,
        PPC_DFPR(FD),DNA,       PPC_DFPR(FA),PPC_DFPR(FB),PPC_DFPR(FC),
        DNA,DNA,DNA,            DNA,DNA)



#define FNMSUB_IMPL                                     \
  {                                                     \
   qword_t _a, _b,_c;                         \
   double double_a, double_b, double_c;            \
   double double_dest;                             \
   qword_t *dest;                                   \
   _a = PPC_FPR_DW(FA);                            \
   _b = PPC_FPR_DW(FB);                            \
   _c = PPC_FPR_DW(FC);          \
	memcpy(&double_a, &_a, sizeof(double) );	\
	memcpy(&double_b, &_b, sizeof(double) );	\
	memcpy(&double_c, &_c, sizeof(double) );	\
   double_dest = -(double_a * double_c - double_b); 	\
   dest = (qword_t *) (&double_dest);               \
   PPC_SET_FPR_DW(FD, *dest);                          \
  }
   
DEFINST(FNMSUB,                       0x3C,
        "fnmsub",                     "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA,          	PPC_DFPSCR, DNA)

#define FNMSUBD_IMPL                                    \
  {                                                     \
	FNMSUB_IMPL													\
	PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000));\
  }

DEFINST(FNMSUBD,                      0x3D,
        "fnmsub.",                    "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        PPC_DCR, DNA, DNA,            PPC_DFPSCR, PPC_DCR)



#define FMUL_IMPL                                       \
{                                                     \
	qword_t _a, _c;                               \
	qword_t *dest;										\
	double double_a, double_c, double_dest;							\
	_a = PPC_FPR_DW(RA);                                \
	_c = PPC_FPR_DW(RC);                                \
 	memcpy(&double_a, &_a, sizeof(double) );	\
 	memcpy(&double_c, &_c, sizeof(double) );	\
	double_dest = double_a * double_c;			\
	dest = (qword_t *) (&double_dest);			\
	PPC_SET_FPR_DW(FD, *dest);                              \
}

DEFINST(FMUL,                   	0x32,
        "fmul",                 	"D,A,C",
        FloatMULT,              	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FC), PPC_DFPSCR,
        DNA, DNA, DNA,          	DNA, DNA)
  


#define FMULD_IMPL                                      \
  {                                                     \
	FMUL_IMPL														\
	PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }
        
DEFINST(FMULD,                  	0x33,
        "fmul.",                	"D,A,C",
        FloatMULT,              	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FC), PPC_DFPSCR,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)


#define FMSUB_IMPL                                      \
  {                                                     \
   qword_t _a, _b,_c;                         \
   double double_a, double_b, double_c;            \
   double double_dest;                             \
   qword_t *dest;                                   \
   _a = PPC_FPR_DW(FA);                            \
   _b = PPC_FPR_DW(FB);                            \
   _c = PPC_FPR_DW(FC);          \
	memcpy(&double_a, &_a, sizeof(double) );	\
	memcpy(&double_b, &_b, sizeof(double) );	\
	memcpy(&double_c, &_c, sizeof(double) );	\
   double_dest = double_a * double_c - double_b;    \
   dest = (qword_t *) &double_dest;			\
   PPC_SET_FPR_DW(FD, *dest);                          \
  }
        
DEFINST(FMSUB,                        0x38,   
        "fmsub",                      "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA,                PPC_DFPSCR, DNA)





#define FMSUBD_IMPL                                     \
  {                                                     \
	FMSUB_IMPL														\
  	PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }
   
DEFINST(FMSUBD,                       0x39,
        "fmsub.",                     "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        PPC_DCR, DNA, DNA,            PPC_DFPSCR, PPC_DCR)




        
#define FMADD_IMPL                                      \
  {                                                     \
	qword_t _a, _b,_c;                         \
	double double_a, double_b, double_c;				\
	double double_dest;										\
	qword_t *dest;												\
	_a = PPC_FPR_DW(FA);                            \
	_b = PPC_FPR_DW(FB);                            \
	_c = PPC_FPR_DW(FC);				\
	memcpy(&double_a, &_a, sizeof(double) );	\
	memcpy(&double_b, &_b, sizeof(double) );	\
	memcpy(&double_c, &_c, sizeof(double) );	\
	double_dest = double_a * double_c + double_b;			\
	dest = (qword_t *) (&double_dest);					\
	PPC_SET_FPR_DW(FD, *dest);                          \
  }

DEFINST(FMADD,                        0x3A,
        "fmadd",                      "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,      PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA,                PPC_DFPSCR, DNA)



#define FMADDD_IMPL                                     \
  {                                                     \
	FMADD_IMPL													\
   PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }

DEFINST(FMADDD,                       0x3B,
        "fmadd.",                     "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA,                PPC_DFPSCR, PPC_DCR)


#define FNMADD_IMPL                                     \
  {                                                     \
   qword_t _a, _b,_c;                         \
   double double_a, double_b, double_c;            \
   double double_dest;                             \
   qword_t *dest;                                   \
   _a = PPC_FPR_DW(FA);                            \
   _b = PPC_FPR_DW(FB);                            \
   _c = PPC_FPR_DW(FC);          \
	memcpy(&double_a, &_a, sizeof(double) );	\
	memcpy(&double_b, &_b, sizeof(double) );	\
	memcpy(&double_c, &_c, sizeof(double) );	\
   double_dest = -(double_a * double_c + double_b);     \
   dest = (qword_t *) (&double_dest);               \
   PPC_SET_FPR_DW(FD, *dest);                          \
  }



DEFINST(FNMADD,                       0x3E,
        "fnmadd",                     "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA,                PPC_DFPSCR, DNA)


#define FNMADDD_IMPL                                    \
  {                                                     \
	FNMADD_IMPL											\
	PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }

DEFINST(FNMADDD,                      0x3F,   
        "fnmadd.",                    "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        PPC_DCR, DNA, DNA,            PPC_DFPSCR, PPC_DCR)





#define MTFSFI_IMPL							\
   {                                                                    \
	word_t _m,_f;							\
	_f = FPSCR;							\
	if(CRFD!=0){							\
		_m = 15 << ((7-CRFD)*4);				\
		_f = (_f & (~(_m)))| (MTFSFI_IMM <<((7-CRFD)*4) );	\
	}								\
	else{								\
		_m = 0x6 <<28;						\
		_f = (_f & (~(_m)))| ( (MTFSFI_IMM & 0x6) <<28);	\
	}								\
	PPC_SET_FPSCR(_f);						\
   }

DEFINST(MTFSFI,                 0x10C,
        "mtfsfi",               "D",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DFPSCR,DNA,         PPC_DFPSCR,DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)



#define MTFSFID_IMPL                                                    \
   {                                                                    \
        word_t _m,_f;                                                   \
        _f = FPSCR;                                                     \
        if(CRFD!=0){                                                    \
                _m = ((0xf) << ((7-CRFD)*4));                           \
                _f = (_f & (~(_m)))| (MTFSFI_IMM <<((7-CRFD)*4) );      \
        }                                                               \
        else{                                                           \
                _m = 0x6 <<28;						\
                _f = (_f & (~(_m)))| ( (MTFSFI_IMM & 0x6) <<28 );	\
        }                                                               \
	PPC_SET_FPSCR(_f);						\
        PPC_SET_CR( (CR & ~( 0x0f000000)) | (FPSCR & 0x0f000000) );     \
   }


DEFINST(MTFSFID,                0x10D,
        "mtfsfi.",              "D",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DFPSCR,PPC_DCR,     PPC_DFPSCR,PPC_DCR,DNA,
        DNA, DNA, DNA,        	DNA, DNA)



#define MTFSF_IMPL                                                    	\
   {									\
        word_t _m,_f, _fm, _rb,_c;					\
	int _i;								\
	_rb = PPC_FPR_W(FB);						\
	_f=FPSCR;							\
	_fm = MTFSFI_FM;						\
	if(_fm & 0x80)							\
	{								\
	 _m = 0x60000000;						\
	}								\
	else{								\
	 _m=0x0;							\
	}								\
	_c=0x1;								\
	for(_i=0;_i<7;_i++){						\
		if(_c & _fm)						\
		{							\
			_m= _m | (0xf<<(_i*4));				\
		}							\
		_c=_c<<1;						\
	}								\
	_f = _rb & _m ;						        \
	PPC_SET_FPSCR(_f);						\
   }


DEFINST(MTFSF,                 0x58E,
        "mtfsf",               "M,B",
        IntALU,                F_ICOMP,
        PPC_DFPSCR,DNA,        PPC_DFPSCR,PPC_DFPR(FB),DNA,
        DNA, DNA, DNA,         DNA, DNA)



#define MTFSFD_IMPL							\
   {                                                                    \
        word_t _m,_f, _fm, _rb,_c;                                      \
        int _i;                                                         \
        _rb = PPC_FPR_W(FB);                                            \
        _f=FPSCR;                                                       \
        _fm = MTFSFI_FM;                                                \
        if(_fm & 0x80)                                                  \
        {                                                               \
         _m = 0x60000000;                                               \
        }                                                               \
        else{                                                           \
         _m=0x0;                                                        \
        }                                                               \
        _c=0x1;                                                         \
        for(_i=0;_i<7;_i++){                                            \
                if(_c & _fm)                                            \
                {                                                       \
                        _m= _m | (0xf<<(_i*4));                         \
                }                                                       \
                _c=_c<<1;                                               \
        }                                                               \
        _f = _rb & _m;						        \
        PPC_SET_FPSCR(_f);                                              \
	PPC_SET_CR( (_f & 0x0f000000) | (CR & 0xf0ffffff));		\
   }

DEFINST(MTFSFD,                0x58F,
        "mtfsf.",              "M,B",
        IntALU,                F_ICOMP,
        PPC_DFPSCR,PPC_DCR,    PPC_DFPSCR,PPC_DFPR(FB),DNA,
        DNA, DNA, DNA,         DNA, DNA)

#define FABS_IMPL					\
   {							\
   qword_t _d;                               \
   qword_t *dest;                             \
   double double_a, double_dest;                     \
   word_t *ptempf;                              \
   _d = PPC_FPR_DW(FB);                                \
   memcpy(&double_a, &_d, sizeof(double) );		\
   ptempf = (word_t *) (&double_a);                   \
   double_dest = fabs(double_a) ;        \
   dest = (qword_t *) (&double_dest);         \
   PPC_SET_FPR_DW(FD, *dest);                              \
}

DEFINST(FABS,			0x210,
	"fabs",			"D,B",
	FloatADD,		F_FCOMP,	
	PPC_DFPR(FD), DNA,      PPC_DFPR(FB), DNA, DNA,
        DNA, DNA, DNA,          DNA, DNA)



#define FABSD_IMPL                                                      \
   {                                                                    \
        FABS_IMPL;				\
	PPC_SET_CR( (CR & 0xf0ffffff) | (((FPSCR)>>4) & 0x0f000000)  );	\
   }

DEFINST(FABSD,                  0x211,
        "fabs.",                "D,B",
        FloatADD,               F_FCOMP,
        PPC_DFPR(FD), PPC_DCR,  PPC_DFPR(FB), PPC_DFPSCR, PPC_DCR,
        DNA, DNA, DNA,          DNA, DNA)

 
#define FNABS_IMPL                                               \
   {                                                             \
   qword_t _d;                               \
   qword_t *dest;                             \
   double double_a, double_dest;                     \
   word_t *ptempf;                              \
   _d = PPC_FPR_DW(FB);                                \
   memcpy(&double_a, &_d, sizeof(double) );		\
   ptempf = (word_t *) (&double_a);                   \
   double_dest = -fabs(double_a) ;        \
   dest = (qword_t *) (&double_dest);         \
   PPC_SET_FPR_DW(FD, *dest);                              \
}

DEFINST(FNABS,                  0x110,
        "fnabs",                "D,B",
        FloatADD,               F_FCOMP,
        PPC_DFPR(FD), DNA,      PPC_DFPR(FB), DNA, DNA,
        DNA, DNA, DNA,          DNA, DNA)


#define FNABSD_IMPL                                                     \
   {                                                                    \
	FNABS_IMPL;				\
	PPC_SET_CR( (CR & 0xf0ffffff) | (((FPSCR)>>4) & 0x0f000000)  );	\
   }

DEFINST(FNABSD,                 0x111,
        "fnabs.",               "D,B",
        FloatADD,               F_FCOMP,
        PPC_DFPR(FD), DNA,      PPC_DFPR(FB), PPC_DFPSCR, PPC_DCR,
        DNA, DNA, DNA,          DNA, DNA)

#define MFFS_IMPL                                                       \
   {                                                            	\
      qword_t _f;							\
      _f= (qword_t)FPSCR;						\
	  	PPC_SET_FPR_DW(FD, _f);						\
   }


DEFINST(MFFS,                   0x48E,
        "mffs",                 "D",
        IntALU,                 F_ICOMP,
        PPC_DFPR(FD),PPC_DCR,   PPC_DFPSCR,PPC_DCR,DNA,
        DNA, DNA, DNA,        	DNA, DNA)



#define MFFSD_IMPL                                               \
   {                                                             \
	word_t _c, _fp;                                          \
        qword_t _f;                                               \
        _f= (qword_t)FPSCR;                                       \
        PPC_SET_FPR_DW(FD, _f);                                  \
	_c = CR;						 \
	_fp = FPSCR;						 \
	PPC_SET_CR( (CR & ~( 0x0f000000)) | (FPSCR & 0x0f000000) );	 \
   }
        

DEFINST(MFFSD,                  0x48F, 
        "mffs.",                "D",
        IntALU,                 F_ICOMP,
        PPC_DFPR(FD),PPC_DCR,   PPC_DFPSCR,PPC_DCR,DNA,
        DNA, DNA, DNA,        	DNA, DNA)
   

#define FSQRT_IMPL					\
   {							\
	qword_t _a;                               \
   qword_t *dest;                             \
   double double_a, double_dest;                     \
   _a = PPC_FPR_DW(FB);                                \
	memcpy(&double_a, &_a, sizeof(double) ); \
	double_dest = (double) sqrt(double_a) ;	\
   dest = (qword_t *) (&double_dest);         \
   PPC_SET_FPR_DW(FD, *dest);                              \
   }


DEFINST(FSQRT,			        0x2C,
	"fsqrt",			"D,B",
	FloatSQRT,			F_FCOMP,
	PPC_DFPR(FD), PPC_DFPSCR,	PPC_DFPR(FB), PPC_DFPSCR,DNA,
	DNA, DNA, DNA,			DNA,DNA)


#define FSQRTD_IMPL					\
   {							\
		FSQRT_IMPL;				\
        PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
   }

DEFINST(FSQRTD,			        0x2D,
	"fsqrt.",			"D,B",
	FloatSQRT,			F_FCOMP,
	PPC_DFPR(FD), PPC_DFPSCR,	PPC_DFPR(FB), PPC_DFPSCR,DNA,
	PPC_DCR, DNA, DNA,		DNA,DNA)



#define FRSQRTE_IMPL					\
   {							\
	qword_t _b,_fc;				\
	dfloat_t _fb;					\
	qword_t _a;		        		\
	word_t _fp;		        		\
	_b =  PPC_FPR_DW(FB);				\
	_fb = PPC_FPR(FB);				\
	if(_b==NEGINFSP){				\
		 PPC_SET_FPR_DW(FD,_b|ULL(0x0008000000000000));     \
		 PPC_SET_FPSCR_FPRF(0x11);		\
		 PPC_SET_FPSCR_FX;			\
		 PPC_SET_FPSCR_VXSQRT;			\
	}						\
	else if(_b==POSINFSP){				\
		 PPC_SET_FPR_DW(FD,POSZEROSP);		\
		 PPC_SET_FPSCR_FPRF(0x02);		\
	}						\
	else if(_b==NEGZEROSP){				\
		 PPC_SET_FPR_DW(FD,NEGINFSP);		\
		 PPC_SET_FPSCR_ZX;			\
		 PPC_SET_FPSCR_FX;			\
		 PPC_SET_FPSCR_FPRF(0x09);		\
	}						\
	else if(_b==POSZEROSP){				\
	 	PPC_SET_FPR_DW(FD,POSINFSP);		\
		PPC_SET_FPSCR_ZX;			\
		PPC_SET_FPSCR_FX;			\
		PPC_SET_FPSCR_FPRF(0x3);		\
	}						\
	else if(isspSNan(_b)){				\
		PPC_SET_FPR_DW(FD,_b|ULL(0x0008000000000000));	\
		PPC_SET_FPSCR_VXSNAN;			\
		PPC_SET_FPSCR_FX;			\
		PPC_SET_FPSCR_FPRF(0x11);		\
	}						\
	else if(isspQNan(_b)){				\
		PPC_SET_FPR_DW(FD,_b);      		\
                PPC_SET_FPSCR_FPRF(0x11);               \
	}						\
        else if(_fp<0){				        \
		 PPC_SET_FPR_DW(FD,_b|ULL(0x7ff8000000000000));     \
		 PPC_SET_FPSCR_FPRF(0x11);		\
		 PPC_SET_FPSCR_FX;			\
		 PPC_SET_FPSCR_VXSQRT;			\
	}						\
	else {						\
		_fb=1.0/sqrt(_fb);			\
		_fp=FPSCR;				\
                PPC_SET_FPSCR(_fp);                     \
                _fc = *(qword_t *)&_fb;                  \
                PPC_SET_FPR_DW(FD,_fc);                 \
		_a = *(qword_t*)(& _fb);		        \
		if(_fb<0.0){				\
			if(_a&ULL(0x7f80000000000000)) PPC_SET_FPSCR_FPRF(0x8);\
			else PPC_SET_FPSCR_FPRF(0x18);	\
		}					\
		else{					\
			if(_a&ULL(0x7f80000000000000)) PPC_SET_FPSCR_FPRF(0x4);\
                        else PPC_SET_FPSCR_FPRF(0x14);	\
		}					\
	}						\
   }

DEFINST(FRSQRTE,			0x34,
	"frsqrte",			"D,B",
	FloatSQRT,			F_FCOMP,
	PPC_DFPR(FD), PPC_DFPSCR,	PPC_DFPR(FB), PPC_DFPSCR,DNA,
	DNA, DNA, DNA,			DNA,DNA)


#define FRSQRTED_IMPL					\
   {							\
	qword_t _b,_fc;				\
	dfloat_t _fb;					\
	qword_t _a;			          	\
	word_t _fp;		        		\
	_b =  PPC_FPR_DW(FB);				\
	_fb = PPC_FPR(FB);				\
	if(_b==NEGINFSP){				\
		 PPC_SET_FPR_DW(FD,_b|ULL(0x0008000000000000));     \
		 PPC_SET_FPSCR_FPRF(0x11);		\
		 PPC_SET_FPSCR_FX;			\
		 PPC_SET_FPSCR_VXSQRT;			\
	}						\
	else if(_b==POSINFSP){				\
		 PPC_SET_FPR_DW(FD,POSZEROSP);		\
		 PPC_SET_FPSCR_FPRF(0x02);		\
	}						\
	else if(_b==NEGZEROSP){				\
		 PPC_SET_FPR_DW(FD,NEGINFSP);		\
		 PPC_SET_FPSCR_ZX;			\
		 PPC_SET_FPSCR_FX;			\
		 PPC_SET_FPSCR_FPRF(0x09);		\
	}						\
	else if(_b==POSZEROSP){				\
	 	PPC_SET_FPR_DW(FD,POSINFSP);		\
		PPC_SET_FPSCR_ZX;			\
		PPC_SET_FPSCR_FX;			\
		PPC_SET_FPSCR_FPRF(0x3);		\
	}						\
	else if(isspSNan(_b)){				\
		PPC_SET_FPR_DW(FD,_b|ULL(0x0008000000000000));	\
		PPC_SET_FPSCR_VXSNAN;			\
		PPC_SET_FPSCR_FX;			\
		PPC_SET_FPSCR_FPRF(0x11);		\
	}						\
	else if(isspQNan(_b)){				\
		PPC_SET_FPR_DW(FD,_b);      		\
                PPC_SET_FPSCR_FPRF(0x11);               \
	}						\
        else if(_fp<0){				        \
		 PPC_SET_FPR_DW(FD,_b|ULL(0x7ff8000000000000));     \
		 PPC_SET_FPSCR_FPRF(0x11);		\
		 PPC_SET_FPSCR_FX;			\
		 PPC_SET_FPSCR_VXSQRT;			\
	}						\
	else {						\
		_fb=1.0/sqrt(_fb);			\
        	_fp=FPSCR;				\
                PPC_SET_FPSCR(_fb);                     \
                _fc = *(qword_t *)&_fb;                  \
                PPC_SET_FPR_DW(FD,_fc);                    \
		_a = *(qword_t*)(& _fb);		        \
		if(_fb<0.0){				\
			if(_a&ULL(0x7f80000000000000)) PPC_SET_FPSCR_FPRF(0x8);\
			else PPC_SET_FPSCR_FPRF(0x18);	\
		}					\
		else{					\
			if(_a&ULL(0x7f80000000000000)) PPC_SET_FPSCR_FPRF(0x4);\
                        else PPC_SET_FPSCR_FPRF(0x14);	\
		}					\
	}						\
        PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
   }

DEFINST(FRSQRTED,			0x35,
	"frsqrte.",			"D,B",
	FloatSQRT,			F_FCOMP,
	PPC_DFPR(FD), PPC_DFPSCR,	PPC_DFPR(FB), PPC_DFPSCR,DNA,
	PPC_DCR, DNA, DNA,		DNA,DNA)









/* clean up all definitions... */
#undef NOP_IMPL
/*Clean up Integer arithmetic defs*/

#undef NEWINST_IMPL

#undef ADD_IMPL
#undef ADDD_IMPL
#undef ADDO_IMPL
#undef ADDOD_IMPL
#undef ADDC_IMPL
#undef ADDCD_IMPL
#undef ADDCO_IMPL
#undef ADDCOD_IMPL
#undef ADDE_IMPL
#undef ADDED_IMPL
#undef ADDEO_IMPL
#undef ADDEOD_IMPL
#undef ADDI_IMPL
#undef ADDIC_IMPL
#undef ADDICD_IMPL
#undef ADDIS_IMPL
#undef ADDME_IMPL
#undef ADDMED_IMPL
#undef ADDMEO_IMPL
#undef ADDMEOD_IMPL
#undef ADDZE_IMPL
#undef ADDZED_IMPL
#undef ADDZEO_IMPL
#undef ADDZEOD_IMPL
#undef DIVW_IMPL
#undef DIVWD_IMPL
#undef DIVWO_IMPL
#undef DIVWOD_IMPL
#undef DIVWU_IMPL
#undef DIVWUD_IMPL
#undef DIVWUO_IMPL
#undef DIVWUOD_IMPL
#undef MULHW_IMPL
#undef MULHWD_IMPL
#undef MULHWU_IMPL
#undef MULHWUD_IMPL
#undef MULLI_IMPL
#undef MULLW_IMPL
#undef MULLWD_IMPL
#undef MULLWO_IMPL
#undef MULLWOD_IMPL
#undef NEG_IMPL
#undef NEGD_IMPL
#undef NEGO_IMPL
#undef NEGOD_IMPL
#undef SUBF_IMPL
#undef SUBFD_IMPL
#undef SUBFO_IMPL
#undef SUBFOD_IMPL
#undef SUBFC_IMPL
#undef SUBFCD_IMPL
#undef SUBFCO_IMPL
#undef SUBFCOD_IMPL
#undef SUBFIC_IMPL
#undef SUBFE_IMPL
#undef SUBFED_IMPL
#undef SUBFEO_IMPL
#undef SUBFEOD_IMPL
#undef SUBFME_IMPL
#undef SUBFMED_IMPL
#undef SUBFMEO_IMPL
#undef SUBFMEOD_IMPL
#undef SUBFZE_IMPL
#undef SUBFZED_IMPL
#undef SUBFZEO_IMPL
#undef SUBFZEOD_IMPL


/*Integer compare instructions*/
#undef CMP_IMPL
#undef CMPI_IMPL
#undef CMPI_IMPL
#undef CMPLI_IMPL


/*Integer logical instructions*/
#undef AND_IMPL
#undef ANDD_IMPL
#undef ANCD_IMPL
#undef ANDCD_IMPL
#undef ANDID_IMPL
#undef ANDISD_IMPL
#undef CNTLZW_IMPL
#undef CNTLZWD_IMPL
#undef EQV_IMPL
#undef EQVD_IMPL
#undef EXTSB_IMPL
#undef EXTSBD_IMPL
#undef EXTSH_IMPL
#undef EXTSHD_IMPL
#undef NAND_IMPL
#undef NANDD_IMPL
#undef NOR_IMPL
#undef NORD_IMPL
#undef OR_IMPL
#undef ORD_IMPL
#undef ORC_IMPL
#undef ORCD_IMPL
#undef ORI_IMPL
#undef ORIS_IMPL
#undef XOR_IMPL
#undef XORD_IMPL
#undef XORI_IMPL
#undef XORIS_IMPL


/*Integer rotate instructions*/

#undef RLWIMI_IMPL
#undef RLWIMID_IMPL
#undef RLWINM_IMPL
#undef RLWINMD_IMPL
#undef RLWNM_IMPL
#undef RLWNMD_IMPL

/*Integer shift instructions*/
#undef SLW_IMPL
#undef SLWD_IMPL
#undef SRAW_IMPL
#undef SRAWD_IMPL
#undef SRAWI_IMPL
#undef SRAWID_IMPL
#undef SRW_IMPL
#undef SRWD_IMPL

/*Floating point arithmetic instructions*/
#undef FADD_IMPL
#undef FADDD_IMPL
#undef FADDS_IMPL
#undef FADDSD_IMPL
#undef FDIV_IMPL
#undef FDIVD_IMPL
#undef FDIVS_IMPL
#undef FDIVSD_IMPL
#undef FMUL_IMPL
#undef FMULD_IMPL
#undef FMULS_IMPL
#undef FMULSD_IMPL
#undef FRES_IMPL
#undef FRESD_IMPL
#undef FRSQRTE_IMPL
#undef FRSQRTED_IMPL
#undef FSUB_IMPL
#undef FSUBD_IMPL
#undef FSUBS_IMPL
#undef FSUBSD_IMPL
#undef FSEL_IMPL
#undef FSELD_IMPL
#undef FMADD_IMPL
#undef FMADDD_IMPL
#undef FMADDS_IMPL
#undef FMADDSD_IMPL
#undef FMSUB_IMPL
#undef FMSUBD_IMPL
#undef FMSUBS_IMPL
#undef FMSUBSD_IMPL
#undef FNMADD_IMPL
#undef FNMADDD_IMPL
#undef FNMADDS_IMPL
#undef FNMADDSD_IMPL
#undef FNMSUB_IMPL
#undef FNMSUBD_IMPL
#undef FNMSUBS_IMPL
#undef FNMSUBSD_IMPL

/* Floating point rounding and conversion instructions*/
#undef FCTIW_IMPL
#undef FCTIWD_IMPL
#undef FCTIWZ_IMPL
#undef FCTIWZD_IMPL
#undef FCTID_IMPL
#undef FRSP_IMPL
#undef FRSPD_IMPL

/*Floating point compare instructions*/
#undef FCMPO_IMPL
#undef FCMPU_IMPL

/*Integer Load instructions*/
#undef LBZ_IMPL
#undef LBZU_IMPL
#undef LBZUX_IMPL
#undef LBZX_IMPL
#undef LHA_IMPL
#undef LHAU_IMPL
#undef LHAX_IMPL
#undef LHAUX_IMPL
#undef LHZ_IMPL
#undef LHZU_IMPL
#undef LHZX_IMPL
#undef LHZUX_IMPL
#undef LWZ_IMPL
#undef LWZU_IMPL
#undef LWZX_IMPL
#undef LWZUX_IMPL

/*Integer store instructions*/
#undef STB_IMPL
#undef STBU_IMPL
#undef STBUX_IMPL
#undef STBX_IMPL
#undef STH_IMPL
#undef STHU_IMPL
#undef STHUX_IMPL
#undef STHX_IMPL
#undef STW_IMPL
#undef STWU_IMPL
#undef STWUX_IMPL
#undef STWX_IMPL

/*Integer load and store with byte reverse instructions*/
#undef LHBRX_IMPL
#undef LWBRX_IMPL
#undef STHBRX_IMPL
#undef STWBRX_IMPL

/*Integer load and store multiple instructions*/
#undef LMW_IMPL
#undef STMW_IMPL

/*Integer load and store string instructions*/
#undef LSWI_IMPL
#undef LSWX_IMPL
#undef STSWI_IMPL
#undef STSWX_IMPL

/*Memory synchronization instructions*/
#undef EIEIO_IMPL
#undef ISYNC_IMPL
#undef LWARX_IMPL
#undef STWCXD_IMPL
#undef SYNC_IMPL

/*Floating point load instructions*/

#undef LFD_IMPL
#undef LFDU_IMPL
#undef LFDX_IMPL
#undef LFDUX_IMPL
#undef LFS_IMPL
#undef LFSU_IMPL
#undef LFSX_IMPL
#undef LFSUX_IMPL


/*Floating point store instructions*/
#undef STFD_IMPL
#undef STFDU_IMPL
#undef STFDX_IMPL
#undef STFDUX_IMPL
#undef STFIWX_IMPL
#undef STFS_IMPL
#undef STFSU_IMPL
#undef STFSX_IMPL
#undef STFSUX_IMPL

/*Floating point move instructions*/
#undef FABS_IMPL
#undef FABSD_IMPL
#undef FMR_IMPL
#undef FMRD_IMPL
#undef FNABS_IMPL
#undef FNABSD_IMPL
#undef FNEG_IMPL
#undef FNEGD_IMPL



/*Floating point status and control register instructions*/
#undef MCRF_IMPL
#undef MCRFS_IMPL
#undef MFFS_IMPL
#undef MFFSD_IMPL
#undef MTFSB0_IMPL
#undef MTFSB0D_IMPL
#undef MTFSB1_IMPL
#undef MTFSB1D_IMPL
#undef MTFSF_IMPL
#undef MTFSF_IMPL
#undef MTFSFI_IMPL
#undef MTFSFID_IMPL



/*Clean up branch defs*/

#undef B_IMPL
#undef BA_IMPL
#undef BL_IMPL
#undef BLA_IMPL
#undef BC_IMPL
#undef BCA_IMPL
#undef BCL_IMPL
#undef BCLA_IMPL
#undef BCCTR_IMPL
#undef BCCTRL_IMPL
#undef BCLR_IMPL
#undef BCLRL_IMPL


/*Condition register logical instructions*/
#undef CRAND_IMPL
#undef CRANDC_IMPL
#undef CREQV_IMPL
#undef CRNAND_IMPL
#undef CRNOR_IMPL
#undef CROR_IMPL
#undef CRORC_IMPL
#undef CRXOR_IMPL
#undef MCRF_IMPL


/*System Linkage instructions*/

#undef SC_IMPL

/*Trap instructions*/

#undef TW_IMPL
#undef TWI_IMPL

/*Processor control instructions*/

#undef MCRXR_IMPL
#undef MFCR_IMPL
#undef MFSPR_IMPL
#undef MFTB_IMPL
#undef MTCRF_IMPL
#undef MTSPR_IMPL

/*Cache management instructions*/
#undef DCBF_IMPL
#undef DCBST_IMPL
#undef DCBT_IMPL
#undef DCBTST_IMPL
#undef DCBZ_IMPL
#undef ICBI_IMPL



/*External control instructions*/
#undef ECIWX_IMPL
#undef ECOWX_IMPL


/*Others */

#undef DEFINST

#undef DEFTRACE // jdonald
/*These havn't been used in this file*/
#undef DEFLINK
#undef CONNECT
